= Rendering a person
:toc: right
:imagesdir: media/
:sourcedir: ../src/main/resources/
:snippet: ../code-samples/code-snippets/

Render your first React4XP page

== Add to site

In a few steps we connect the application to the Headless Movie DB, and should be rewarded gloriously.

. Visit http://localhost:8080/admin^[localhost:8080/admin]. Log in to XP and open Content Studio.
+
. The "Headless Movie Database" project should automatically be selected
+
. Select the root item in the tree structure, and you should see something like this:
+
image:hmdb.png[title="HMDB welcome page", width=855px]
+
. Click btn:[Edit], and connect the React4xp app to the site.
+
image:add-to-site.png[title="Add React4XP application to the site", width=647px]
+
After saving, the preview should change to something like this:
+
image:hello.png[title="React4XP starter page", width=647px]


== Request handling

So, what actually happened here?

The app runs on top of XP's site engine. By adding the application to the site, it is injected into the request pipeline - where it basically hijacks the rendering.

These are the main files involved:

[source,Files]
----
-> react4xp/entries/App.tsx (React entry)
-> react4xp/components/hello/Hello.tsx (Welcome page)
-> types/HelloProps.ts (TypeScript type for props)
-> react4xp/componentRegistry.tsx (R4XP component list)
-> site/components/hello/helloProcessor.ts (props for the Hello component)
-> react4xp/dataFetcher.ts (Map of data processors)
----

Below we backtrack what happened:

=== Hello component

The Hello component that rendered the actual page is very simple:

.react4xp/hello/components/Hello.tsx
[source,TypeScript]
----
include::{sourcedir}react4xp/components/hello/Hello.tsx[]
----

It takes a single parameter, HelloProps. The type is declared like this:

.types/HelloProps.ts
[source,TypeScript]
----
include::{sourcedir}types/HelloProps.ts[]
----

As soon as a component is added to ComponentRegistry which is a registry of React views organized by type, it becomes renderable.

.react4xp/componentRegistry.ts
[source,TypeScript]
----
import {ComponentRegistry} from '@enonic/react-components';
import {Hello} from './components/Hello';

export const componentRegistry = new ComponentRegistry;

componentRegistry.addContentType('portal:site', { View: Hello }); //<1>

----

<1> The Hello component is mapped to the content type `portal:site`, which means it will be executed when the URL matches a site.

NOTE: Try clicking other content items in Content Studio, and you should simply see an error message.


=== HelloProcessor

The responsibility of HelloProcessor is to produce the props required by a component.

DataFetcher is a registry of data fetching functions for components by their type.
It is used in the backend to get props for rendering component views from ComponentRegistry.

.react4xp/components/hello/HelloProcessor.ts
[source,TypeScript]
----
include::{sourcedir}react4xp/components/hello/HelloProcessor.ts[]
----

Similar to a component, a processor is invoked because it is registered in the dataFetcher:

.react4xp/dataFetcher.ts
[source,TypeScript]
----
import {DataFetcher} from '/lib/enonic/react4xp';
import {helloProcessor} from './components/HelloProcessor';

export const dataFetcher = new DataFetcher();

dataFetcher.addContentType('portal:site', { processor: helloProcessor });
----

That is basically it. Throughout the tutorial, you'll be using this extensively.

TIP: Dive deeper into this topic by visiting the <<appendix/controller#, app controller appendix>>. 

== Next

Great, you rendered your first page, next up how about <<rendering-basics.adoc#, adding your own components>>.

