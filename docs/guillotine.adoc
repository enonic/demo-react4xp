= Going Headless, part 1: Guillotine and graphQL
:toc: right
:imagesdir: media/



== Some background

In the previous chapters we've looked at a "traditional CMS" way of using react4xp: as content directly presented (and augmented) by react components, served together by XP. This is fairly easy to set up and works fine for many use cases. But in other cases, we may not want such a tight connection between the content and the presentational components. There may be advantages of handling/serving them separately - or an approach where a content-exposing API works alongside a traditional CMS, as a supplement. These approaches are often called a link:https://enonic.com/blog/headless-or-decoupled-cms[headless] or link:https://enonic.com/blog/what-is-hybrid-cms[hybrid] CMS.

In Enonic XP, project link:https://developer.enonic.com/docs/headless-cms/stable[guillotine] is a go-to solution for extending the existing CMS capabilities. It exposes a read-only link:https://graphql.org/[GraphQL] API, and provides the ability to *read pure content data* (the "body" in the analogy) from XP with great flexibility and high performance.

Combining this with react as the presentational component (the "head") opens up a range of ways to use XP in headless/hybrid manners. This makes guillotine a neat and natural companion to react4xp, so the *guillotine library is included in the react4xp starter* along with two extra helper wrappers.

We will now look at how to use react4xp with guillotine in different ways, for different levels of decoupling.

== Lesson overview

This chapter will focus on setting up the guillotine API and the first usages:

- set up a content type and react visualization for single movie items,
- making *a graphQL query* for content data in a regular XP controller,
- using react4xp to *visualize that data*,
- letting the rendered components make *the same query from the frontend*,
- and use react to dynamically render a visualization of the returned data, and this way fill in more content as we scroll down the page: an *"infinite scroller"* page.

NOTE: The <<webapp#, next chapter>> will expand on this lesson. It demonstrates more decoupled (and less XP-centric) ways to use these same react4xp components in a _standalone webapp_, to render content data from a guillotine API.


=== Source files

.Files involved (src/main/resources/...):
[source,files]
----
react4xp/
    myEntries/                  <!--1-->
        Movie.jsx
        MovieList.jsx
        MovieList.scss
    shared/
        Movie.jsx
        Movie.scss

site/
    content-types
        /movie/
            movie.xml           <!--2-->
    parts/
        movie-list/
            movie-list.es6      <!--3-->
            movie-list.xml
    site.xml                    <!--4-->

controllers/
    previewMovie.es6            <!--5-->

headless/                       <!--6-->
    helpers/
        movieListRequests.es6
    guillotineApi.es6
    guillotineRequest.es6

----
<1> We're going to build a site which is a list of movies, each displayed with a poster and a bit of info. The *entries* _Movie_ and _MovieList_ both import a _shared/Movie_ component. The _Movie_ entry uses it to preview a single movie item inside Content Studio, while the _MovieList_ entry displays the actual movie list site, by iterating over multiple _movie_ data items and using the _shared/Movie_ component for visualizing each item (both in a serverside-rendered and headless context).
<2> A content type for a single _movie_,
<3> A part with a controller that fetches child content items of the _movie_ content type, and renders them into MovieList,
<4> In _site.xml_ we will set up controller mappings for both the guillotine API and...
<5> ...the single-movie preview controller: displays a single movie without needing to set up a template and a part.
<6> _guillotineApi.es6_ is the actual API to guillotine. It can run graphQL queries both from XP controllers and through received HTTP requests. And _guillotineRequest.es6_ simplifies making such a request from the browser. Both of these are general-purpose and come with the starter (since version 1.1.0). But _helpers/movieListRequests.es6_ contains helper functions specific to the lesson site we're building here: it helps with building a query for fetching movie-list data, and parsing the returned data into the `props` format that the _Movie_ component needs. These helpers are also used on both frontend and backend.


{zwsp} +
{zwsp} +
{zwsp} +


== Groundwork: movie items

This first stage should be easy enough, almost entirely repeating steps you've been through in previous chapters. We'll make a _movie_ content type, set up react4xp to preview-render it with react components (but with <<#controller_mapping, a little twist>>), and add some movie items that will be listed when the site is done.

[NOTE]
====
This entire chapter builds on the <<imports-and-dependency-chunks#webpack_config, config setup from the previous lesson>>: _react4xp.properties_, _webpack.config.react4xp.js_ and the extra NPM packages should be set up like that.

If you haven't completed that section already, better take a couple of minutes and do that before proceeding.
====

{zwsp} +

=== Movie content type

When the setup is ready, we'll start by adding a _movie_ *content type*, with an ImageSelector for a poster `image`, a simple HtmlArea with a movie `description`, a numeral Long field for adding the release `year` and an array of `actor` names:

.site/content-types/movie/movie.xml:
[source,xml,options="nowrap"]
----
<content-type xmlns="urn:enonic:xp:model:1.0">
  <display-name>Movie</display-name>
  <description>Moving images often reflecting culture</description>
  <super-type>base:structured</super-type>

  <form>
    <input name="image" type="ImageSelector">
        <label>Movie poster</label>
        <occurrences minimum="1" maximum="1"/>
    </input>

    <input name="description" type="HtmlArea">
        <label>Description</label>
        <config>
            <exclude>*</exclude>
            <include>Bold Italic Underline</include>
        </config>
    </input>

    <input name="year" type="Long">
        <label>Release year</label>
        <occurrences minimum="1" maximum="1"/>
    </input>

    <input name="actor" type="TextLine">
        <label>Actor</label>
        <occurrences minimum="0" maximum="0"/>
    </input>
  </form>
</content-type>
----

{zwsp} +

=== React components

Next, we'll set up a few react components for visualizing each movie item.

The *entry*, _Movie.jsx_, will take care of rendering a preview of each movie content item in content studio later:

.react4xp/myEntries/Movie.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react'

import Movie from '../shared/Movie';

export default (props) => <Movie {...props} />;
----

This is a pure entry wrapper that just imports the next react component from _react4xp/shared_.

Why import code from _shared_ instead of keeping it all in the entry? Two reasons:

- It's a good rule of thumb to keep entries slim, for better optimization.
- Also, in addition to a Content Studio preview for single movies, we're going to use the *imported components* in the actual movie list too, for each single movie in the list. This way, the preview in Content Studio will always directly reflect what's displayed on the final page, because it's the same code that's used everywhere:

.react4xp/shared/Movie.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react'

import './Movie.scss';

const Cast = ({actors}) => (
    <ul className="cast">
        { actors.map( actor => <li key={actor} className="actor">{actor}</li> ) }
    </ul>
);


const Info = ({heading, children}) => (
    <div className="info">
        {heading ? <h3>{heading}</h3> : null}
        {children}
    </div>
);


const InfoContainer = ({title, year, description, actors}) => (
    <div className="infoContainer">
        <h2 className="title">{title}</h2>

        <Info heading="Released">
            <p className="year">{year}</p>
        </Info>

        <Info heading="Description">
            <div className="description"
                 dangerouslySetInnerHTML={{ __html: description }}>
            </div>
        </Info>

        { (actors && actors.length > 0) ?
            <Info heading="Cast">
                <Cast actors={actors} />
            </Info> :
            null
        }
    </div>
);

const Movie = ({imageUrl, title, description, year, actors}) => (
    <div className="movie">
        <img className="poster"
             src={imageUrl}
             alt={`Movie poster: ${title}`}
             title={`Movie poster: ${title}`}/>

        <InfoContainer title={title}
                       year={year}
                       description={description}
                       actors={actors}
        />
    </div>
);

export default Movie;
----

Not a lot of functionality here, just a JSX file that contains some structural units nested inside each other: the exported root level in the component, `Movie`, contains a movie poster image, and nests an `InfoContainer` component that displays the rest of the movie data. There, each movie data section is wrapped in an `Info` component (which just displays a header), and finally each actor name is mapped out in a list in the `Cast` component.

Take a moment to note the *props signature* of _Movie.jsx_. `Movie` clearly expects the `imageUrl` prop to be a URL, so we'll need to handle the `image` field from the content type. Also, since the `description` prop will come from an HtmlArea in the content type it's already in working and pre-escaped HTML form, so we use the react functionality of `dangerouslySetInnerHTML` to insert it instead of just treating it as a string (which would just get escaped again). Next, `title` and `year` are expected to be simple strings (or numbers), and `actors` should be a string array. As you'll see, we'll make sure that each data readout of a movie item will be adapted to this signature, if needed.

Moving on, _Movie.jsx_ also imports some *styling* that'll be handled by webpack the same way as in <<imports-and-dependency-chunks#webpack_rules, the previous chapter>>:


.react4xp/shared/Movie.scss:
[source,sass,options="nowrap"]
----
html, body {
  margin: 0; padding: 0;
}

.infoContainer {
  flex-grow: 1; flex-basis: content; padding: 0; margin: 0;

  * {
    font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif; color: #444;
  }

  h2, h3 {
    padding: 0; margin: 0; color: #0c0c0c;
  }

  h2 {
    font-size: 34px;
  }

  p {
    padding: 0; margin: 10px 0 0 0;
  }
}

.info {
  margin: 0; padding: 30px 0 0 0;
}


.movie {
  margin: 0; padding: 30px; box-sizing: border-box; width: 100%; display: flex; flex-flow: row nowrap; justify-content: flex-start; align-items: flex-start;
}

.poster {
  width: 300px; max-width: 30%; margin-right: 30px; flex: 0 1 auto;
}

.cast {
  list-style-type: none; margin: 0; padding: 0;

  .actor {
    width: 100%; padding: 0; margin: 10px 0 0 0;
  }
}

----

{zwsp} +

[[controller_mapping]]
=== Controller mapping

Here comes a little variation: in this example, we want to connect a movie content item to with the rendering of the _Movie.jsx_ entry. But we don't want to mess around with setting up a <<pages-parts-and-regions#page_template_setup, template with a part>> the way we've done so far. Instead, we can use a link:https://developer.enonic.com/docs/xp/stable/cms/mappings[controller mapping] to make that connection in code.

Let's open _site.xml_ and add a mapping:

.site/site.xml:
[source,xml,options="nowrap"]
----
<?xml version="1.0" encoding="UTF-8"?>
<site>
  <form/>
    <mappings>

        <!-- Add this... -->
        <mapping controller="/controllers/previewMovie.js" order="50">
            <match>type:'com.enonic.app.react4xp:movie'</match>
        </mapping>
        <!-- ...and that's it. -->

    </mappings>
</site>
----

Now, every _movie_ content item in Content Studio is always rendered with a particular controller: _/controllers/previewMovie.js_.

Two important points when using a controller mapping like this:

[NOTE]
====
First, the controller reference in a mapping in _site.xml_ must always refer to *the runtime name of the controller*. In our case, the source file of our controller is _/controllers/previewMovie_ *_.es6_*, but at compile time, this is compiled into *_.js_* which is used at XP runtime.

Second, controller mappings use qualified content type names that have *the name of the app* in it: `com.enonic.app.react4xp`. If/when you use a different name for your app, make sure to update content type references like this, e.g. `<match>type:'my.awesome.app:movie'</match>`
====

Now, with that mapping set up, we can add the _previewMovie_ controller:

.controllers/previewMovie.es6:
[source,javascript,options="nowrap"]
----
const util = require('/lib/util');
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const content = portal.getContent();            <!--1-->

    const props = {
        imageUrl: content.data.image ?
            portal.imageUrl({                       <!--2-->
                id: content.data.image,
                scale: 'width(300)'
            }) :
            undefined,
        title: content.displayName,
        description: portal.processHtml({           <!--3-->
            value: content.data.description
        }),
        year: content.data.year,
        actors: util.data.forceArray( content.data.actor )   <!--4-->
            .map( actor => (actor || '').trim())
            .filter(actor => !!actor)
    };

    const id = content._id;                         <!--5-->

    const output = React4xp.render(
        'Movie',                                    <!--6-->
        props,
        request,
        {
            id,
                                                    <!--7-->
            body: `
                <html>
                    <head>
                        <meta charset="UTF-8" />
                        <title>${content.displayName}</title>
                    </head>
                    <body class="xp-page">
                        <div id="${id}"></div>
                    </body>
                </html>
            `
        }
    );

    output.body = '<!DOCTYPE html>' + output.body;  <!--8-->

    return output;
};
----
After the previous chapters, not much in this controller should come as a surprise, but a quick overview anyway:

<1> We use `getContent` to fetch the movie item data as usual (later, we'll use guillotine in a similar fashion. This doesn't matter as long as the props are constructed according to the signature of _Movie.jsx_).
<2> `image` comes from an ImageSelector and is just an image item ID, so we use `imageUrl` to get the URL that the prop signature expects.
<3> `description` comes from an HtmlArea, so we use `processHtml` to generate a finished HTML string for whatever content that might need it. Now it can be used with `dangerouslySetInnerHTML` in the react component.
<4> Normalizing the `actor` data to guarantee that it's an array.
<5> `React4xp.render` needs a unique ID to target a container in the surrounding `body`.
<6> <<jsxpath#, JsxPath>> reference to _react4xp/myEntries/Movie.jsx_.
<7> This controller is the only one triggered for rendering _movie_ items. That means that the `body` that the rendering is inserted into, has to be a *full root HTML document* including a `<head>` section (or otherwise react4xp won't know where to put the rendered page contributions, and the component won't work properly).
<8> Workaround for a current link:https://github.com/enonic/lib-react4xp/issues/107[inconvenient bug].


{zwsp} +

=== Make some Movies

With all this in place, we're about to finish the groundwork stage: let's add some _movie_ content items to list.

<<hello-react#first_setup_render, Build the project as usual and start XP>>.

Create a site content item and connect it to your app. Create some new Movie items:

[.thumb]
image:edit_movie.png[title="Create a new movie item in content studio", width=1024px]

{zwsp} +

It's important that the new movies are inside/under _one common container item_ in the content hierarchy. It's easiest for this lesson if the movie items are just directly under the site itself:

[.thumb]
image:add_movies.png[title="Create some movie items to list, under the site", width=1024px]

{zwsp} +

When you mark/preview the site itself, you'll see no visualization yet. But previewing each movie item should now work as in the image above.

Now we're ready to move on to more interesting stuff, using the content and code we just made.


====


{zwsp} +

==== React components

{zwsp} +
{zwsp} +
{zwsp} +


== Static movie list

{zwsp} +
{zwsp} +

=== Code

==== Controller: backend guillotine query

{zwsp} +

==== React components

{zwsp} +
{zwsp} +
{zwsp} +

== Making the list dynamic

{zwsp} +

=== Code

==== Activating the guillotine API

{zwsp} +

==== Frontend guillotine API

{zwsp} +

==== Scroll listener and dynamic DOM updates


----

The Part definition enables two editorial configurations:

.site/parts/multi-color/multi-color.xml:
[source,xml,options="nowrap"]
----

----


.site/parts/multi-color/multi-color.es6:
[source,javascript,options="nowrap"]
----

----


{zwsp} +

=== React component

.react4xp/myEntries/MultiColor.jsx:
[source,javascript,options="nowrap"]
----
----

{zwsp} +

=== Dependencies for the entry

==== Styling

.react4xp/myEntries/MultiColor.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

.react4xp/shared/shared-styles.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

==== Imported react components

{zwsp} +

===== Button

.react4xp/shared/Button.jsx:
[source,javascript,options="nowrap"]
----

----

.react4xp/shared/Button.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

===== ActiveColorOval

.react4xp/shared/ActiveColorOval.jsx:
[source,javascript,options="nowrap"]
----

----

.react4xp/shared/ActiveColorOval.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

===== ColorButtons

.react4xp/shared/ColorButtons.jsx:
[source,javascript,options="nowrap"]
----

----

.react4xp/shared/ColorButtons.scss:
[source,sass,options="nowrap"]
----

----


{zwsp} +

[[webpack_config]]
== Configuring react4xp and webpack

In this section we'll adjust some settings to make the code above work.

TIP: Some of this is covered in more detail under <<entries#, entries>> and <<jsxpath#, jsxPaths>>.

{zwsp} +

=== Folders for entries and chunks

.react4xp.properties:
[source,properties,options="nowrap"]
----

----

[NOTE]
====

====

{zwsp} +

=== Adding webpack rules

.react4xp.properties:
[source,properties,options="nowrap"]
----

----

.webpack.config.react4xp.js:
[source,javascript,options="nowrap"]
----

----

{zwsp} +

==== NPM dependencies


[source,bash,options="nowrap"]
----

----

{zwsp} +

== Setup and rendering


.Empty multicolor Part:
image:multicolor-add.png[title="Empty MultiColor part in Content Studio", width=720px]

{zwsp} +


.Multicolor Part with colors filled in:
image:multicolor-added.png[title="MultiColor part in Content Studio, with four colors added", width=720px]

{zwsp} +


.Multicolor Part, active view:
image:multicolor-preview.png[,title="MultiColor part outside of Content Studio, active view after clicking the #5d0015 button", width=720px]

{zwsp} +


== Output

.Page source from the Multicolor Part, active view (serverside rendered not selected):
[source,html,options="nowrap"]
----

----

{zwsp} +

== Further reading

-> <<entries#, Entries>>

-> <<jsxpath#, JsxPath>>

-> <<chunks#, Dependency chunks>>

{zwsp} +

<<api#, API>> reference:

-> <<api#react4xp_render, React4xp.render>>

-> <<api#react4xp_object, React4xp data objects>>

{zwsp} +
{zwsp} +

----


The link:https://iconscout.com/icons/movie[movie icon] that marks the _movie_ content type in the screengrabs is by link:https://iconscout.com/contributors/phoenix-group[Phoenix Dungeon] on link:https://iconscout.com[Iconscout].
