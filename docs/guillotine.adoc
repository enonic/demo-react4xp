= Going Headless, part 1: Guillotine and graphQL
:toc: right
:imagesdir: media/

{zwsp} +

image:guillotine.jpg[title="React4xp goes headless", width=600px]

{zwsp} +

== Some background

In the previous chapters we've looked at a "traditional CMS" way of using react4xp: as content directly presented (and augmented) by react components, served together by XP. This is fairly easy to set up and works fine for many use cases. But in other cases, we may not want such a tight connection between the content and the presentational components. There may be advantages of handling/serving them separately - or an approach where a content-exposing API works alongside a traditional CMS, as a supplement. These approaches are often called a link:https://enonic.com/blog/headless-or-decoupled-cms[headless] or link:https://enonic.com/blog/what-is-hybrid-cms[hybrid] CMS.

In Enonic XP, project link:https://developer.enonic.com/docs/headless-cms/stable[guillotine] is a go-to solution for extending the existing CMS capabilities. It exposes a read-only link:https://graphql.org/[GraphQL] API, and provides the ability to *read pure content data* (the "body" in the analogy) from XP with great flexibility and high performance.

Combining this with react as the presentational component (the "head") opens up a range of ways to use XP in headless/hybrid manners. This makes guillotine a neat and natural companion to react4xp, so the *guillotine library is included in the react4xp starter* along with two extra helper wrappers.

We will now look at how to use react4xp with guillotine in different ways, for different levels of decoupling.

== Lesson overview

This chapter will focus on setting up the guillotine API and the first usages:

- set up a content type and react visualization for single movie items,
- making *a graphQL query* for content data in a regular XP controller,
- using react4xp to *visualize that data*,
- letting the rendered components make *the same query from the frontend*,
- and use react to dynamically render a visualization of the returned data, and this way fill in more content as we scroll down the page: an *"infinite scroller"* page.

NOTE: The <<webapp#, next chapter>> will expand on this lesson. It demonstrates more decoupled (and less XP-centric) ways to use these same react4xp components in a _standalone webapp_, to render content data from a guillotine API.


=== Source files

.Files involved (src/main/resources/...):
[source,files]
----
react4xp/
    myEntries/                  <!--1-->
        Movie.jsx
        MovieList.jsx
        MovieList.scss
    shared/
        Movie.jsx
        Movie.scss

site/
    content-types
        /movie/
            movie.xml           <!--2-->
    parts/
        movie-list/
            movie-list.es6      <!--3-->
            movie-list.xml
    site.xml                    <!--4-->

controllers/
    previewMovie.es6            <!--5-->

headless/                       <!--6-->
    helpers/
        movieListRequests.es6
    guillotineApi.es6
    guillotineRequest.es6

----
<1> We're going to build a site which is a list of movies, each displayed with a poster and a bit of info. The *entries* _Movie_ and _MovieList_ both import a _shared/Movie_ component. The _Movie_ entry uses it to preview a single movie item inside Content Studio, while the _MovieList_ entry displays the actual movie list site, by iterating over multiple _movie_ data items and using the _shared/Movie_ component for visualizing each item (both in a serverside-rendered and headless context).
<2> A content type for a single _movie_,
<3> A part with a controller that fetches child content items of the _movie_ content type, and renders them into MovieList,
<4> In _site.xml_ we will set up controller mappings for both the guillotine API and...
<5> ...the single-movie preview controller: displays a single movie without needing to set up a template and a part.
<6> _guillotineApi.es6_ is the actual API to guillotine. It can run graphQL queries both from XP controllers and through received HTTP requests. And _guillotineRequest.es6_ simplifies making such a request from the browser. Both of these are general-purpose and come with the starter (since version 1.1.0). But _helpers/movieListRequests.es6_ contains helper functions specific to the lesson site we're building here: it helps with building a query for fetching movie-list data, and parsing the returned data into the `props` format that the _Movie_ component needs. These helpers are also used on both frontend and backend.


{zwsp} +
{zwsp} +
{zwsp} +


== Groundwork: movie items

This first stage should be easy enough, almost entirely repeating steps you've been through in previous chapters. We'll make a _movie_ content type, set up react4xp to preview-render it with react components (but with <<#controller_mapping, a little twist>>), and add some movie items that will be listed when the site is done.

[NOTE]
====
This entire chapter builds on the <<imports-and-dependency-chunks#webpack_config, config setup from the previous lesson>>: _react4xp.properties_, _webpack.config.react4xp.js_ and the extra NPM packages should be set up like that.

If you haven't completed that section already, better take a couple of minutes and do that before proceeding.
====

{zwsp} +

=== Movie content type

When the setup is ready, we'll start by adding a _movie_ *content type*, with an ImageSelector for a poster `image`, a simple HtmlArea with a movie `description`, a numeral Long field for adding the release `year` and an array of `actor` names:

.site/content-types/movie/movie.xml:
[source,xml,options="nowrap"]
----
<content-type xmlns="urn:enonic:xp:model:1.0">
  <display-name>Movie</display-name>
  <description>Moving images often reflecting culture</description>
  <super-type>base:structured</super-type>

  <form>
    <input name="image" type="ImageSelector">
        <label>Movie poster</label>
        <occurrences minimum="1" maximum="1"/>
    </input>

    <input name="description" type="HtmlArea">
        <label>Description</label>
        <config>
            <exclude>*</exclude>
            <include>Bold Italic Underline</include>
        </config>
    </input>

    <input name="year" type="Long">
        <label>Release year</label>
        <occurrences minimum="1" maximum="1"/>
    </input>

    <input name="actor" type="TextLine">
        <label>Actor</label>
        <occurrences minimum="0" maximum="0"/>
    </input>
  </form>
</content-type>
----

{zwsp} +

=== React components

Next, we'll set up a few react components for visualizing each movie item.

The *entry*, _Movie.jsx_, will take care of rendering a preview of each movie content item in content studio later:

.react4xp/myEntries/Movie.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react'

import Movie from '../shared/Movie';

export default (props) => <Movie {...props} />;
----

This is a pure entry wrapper that just imports the next react component from _react4xp/shared_.

Why import code from _shared_ instead of keeping it all in the entry? Two reasons:

- It's a good rule of thumb to keep entries slim, for better optimization.
- Also, in addition to a Content Studio preview for single movies, we're going to use the *imported components* in the actual movie list too, for each single movie in the list. This way, the preview in Content Studio will always directly reflect what's displayed on the final page, because it's the same code that's used everywhere:

.react4xp/shared/Movie.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react'

import './Movie.scss';

const Cast = ({actors}) => (
    <ul className="cast">
        { actors.map( actor => <li key={actor} className="actor">{actor}</li> ) }
    </ul>
);


const Info = ({heading, children}) => (
    <div className="info">
        {heading ? <h3>{heading}</h3> : null}
        {children}
    </div>
);


const InfoContainer = ({title, year, description, actors}) => (
    <div className="infoContainer">
        <h2 className="title">{title}</h2>

        <Info heading="Released">
            <p className="year">{year}</p>
        </Info>

        <Info heading="Description">
            <div className="description"
                 dangerouslySetInnerHTML={{ __html: description }}>
            </div>
        </Info>

        { (actors && actors.length > 0) ?
            <Info heading="Cast">
                <Cast actors={actors} />
            </Info> :
            null
        }
    </div>
);

const Movie = ({imageUrl, title, description, year, actors}) => (
    <div className="movie">
        <img className="poster"
             src={imageUrl}
             alt={`Movie poster: ${title}`}
             title={`Movie poster: ${title}`}/>

        <InfoContainer title={title}
                       year={year}
                       description={description}
                       actors={actors}
        />
    </div>
);

export default Movie;
----

Not a lot of functionality here, just a JSX file that contains some structural units nested inside each other: the exported root level in the component, `Movie`, contains a movie poster image, and nests an `InfoContainer` component that displays the rest of the movie data. There, each movie data section is wrapped in an `Info` component (which just displays a header), and finally each actor name is mapped out in a list in the `Cast` component.

Take a moment to note the *props signature* of _Movie.jsx_. `Movie` clearly expects the `imageUrl` prop to be a URL, so we'll need to handle the `image` field from the content type. Also, since the `description` prop will come from an HtmlArea in the content type it's already in working and pre-escaped HTML form, so we use the react functionality of `dangerouslySetInnerHTML` to insert it instead of just treating it as a string (which would just get escaped again). Next, `title` and `year` are expected to be simple strings (or numbers), and `actors` should be a string array. As you'll see, we'll make sure that each data readout of a movie item will be adapted to this signature, if needed.

Moving on, _Movie.jsx_ also imports some *styling* that'll be handled by webpack the same way as in <<imports-and-dependency-chunks#webpack_rules, the previous chapter>>:


.react4xp/shared/Movie.scss:
[source,sass,options="nowrap"]
----
html, body {
  margin: 0; padding: 0;
}

.infoContainer {
  flex-grow: 1; flex-basis: content; padding: 0; margin: 0;

  * {
    font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif; color: #444;
  }

  h2, h3 {
    padding: 0; margin: 0; color: #0c0c0c;
  }

  h2 {
    font-size: 34px;
  }

  p {
    padding: 0; margin: 10px 0 0 0;
  }
}

.info {
  margin: 0; padding: 30px 0 0 0;
}


.movie {
  margin: 0; padding: 30px; box-sizing: border-box; width: 100%; display: flex; flex-flow: row nowrap; justify-content: flex-start; align-items: flex-start;
}

.poster {
  width: 300px; max-width: 30%; margin-right: 30px; flex: 0 1 auto;
}

.cast {
  list-style-type: none; margin: 0; padding: 0;

  .actor {
    width: 100%; padding: 0; margin: 10px 0 0 0;
  }
}

----

{zwsp} +

[[controller_mapping]]
=== Controller mapping

Here comes a little variation: in this example, we want to connect a movie content item to with the rendering of the _Movie.jsx_ entry. But we don't want to mess around with setting up a <<pages-parts-and-regions#page_template_setup, template with a part>> the way we've done so far. Instead, we can use a link:https://developer.enonic.com/docs/xp/stable/cms/mappings[controller mapping] to make that connection in code.

Let's open _site.xml_ and add a mapping:

.site/site.xml:
[source,xml,options="nowrap"]
----
<?xml version="1.0" encoding="UTF-8"?>
<site>
  <form/>
    <mappings>

        <!-- Add this... -->
        <mapping controller="/controllers/previewMovie.js" order="50">
            <match>type:'com.enonic.app.react4xp:movie'</match>
        </mapping>
        <!-- ...and that's it. -->

    </mappings>
</site>
----

Now, every _movie_ content item in Content Studio is always rendered with a particular controller: _/controllers/previewMovie.js_.

Two important points when using a controller mapping like this:

[NOTE]
====
First, the controller reference in a mapping in _site.xml_ must always refer to *the runtime name of the controller*. In our case, the source file of our controller is _/controllers/previewMovie_ *_.es6_*, but at compile time, this is compiled into *_.js_* which is used at XP runtime.

Second, controller mappings use qualified content type names that have *the name of the app* in it: `com.enonic.app.react4xp`. If/when you use a different name for your app, make sure to update content type references like this, e.g. `<match>type:'my.awesome.app:movie'</match>`
====

Now, with that mapping set up, we can add the _previewMovie_ controller:

.controllers/previewMovie.es6:
[source,javascript,options="nowrap"]
----
const util = require('/lib/util');
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const content = portal.getContent();            <!--1-->

    const props = {
        imageUrl: content.data.image ?
            portal.imageUrl({                       <!--2-->
                id: content.data.image,
                scale: 'width(300)'
            }) :
            undefined,
        title: content.displayName,
        description: portal.processHtml({           <!--3-->
            value: content.data.description
        }),
        year: content.data.year,
        actors: util.data.forceArray( content.data.actor )   <!--4-->
            .map( actor => (actor || '').trim())
            .filter(actor => !!actor)
    };

    const id = content._id;                         <!--5-->

    const output = React4xp.render(
        'Movie',                                    <!--6-->
        props,
        request,
        {
            id,
                                                    <!--7-->
            body: `
                <html>
                    <head>
                        <meta charset="UTF-8" />
                        <title>${content.displayName}</title>
                    </head>
                    <body class="xp-page">
                        <div id="${id}"></div>
                    </body>
                </html>
            `
        }
    );

    output.body = '<!DOCTYPE html>' + output.body;  <!--8-->

    return output;
};
----
After the previous chapters, not much in this controller should come as a surprise, but a quick overview anyway:

<1> We use `getContent` to fetch the movie item data as usual (later, we'll use guillotine in a similar fashion. This doesn't matter as long as the props are constructed according to the signature of _Movie.jsx_).
<2> `image` comes from an ImageSelector and is just an image item ID, so we use `imageUrl` to get the URL that the prop signature expects.
<3> `description` comes from an HtmlArea, so we use `processHtml` to generate a finished HTML string for whatever content that might need it. Now it can be used with `dangerouslySetInnerHTML` in the react component.
<4> Normalizing the `actor` data to guarantee that it's an array.
<5> `React4xp.render` needs a unique ID to target a container in the surrounding `body`.
<6> `"Movie"` is of course the <<jsxpath#, jsxPath>> reference to the entry, _react4xp/myEntries/Movie.jsx_.
<7> This controller is the only one triggered for rendering _movie_ items. That means that the `body` that the rendering is inserted into, has to be a *full root HTML document* including a `<head>` section (or otherwise react4xp won't know where to put the rendered page contributions, and the component won't work properly).
<8> Workaround for a current link:https://github.com/enonic/lib-react4xp/issues/107[inconvenient bug].


{zwsp} +

=== Make some Movies

With all this in place, we're about to finish the groundwork stage: let's add some _movie_ content items to list.

<<hello-react#first_setup_render, Build the project as usual and start XP>>.

Create a site content item and connect it to your app. Create some new Movie items:

[.thumb]
image:edit_movie.png[title="Create a new movie item in content studio", width=1024px]

{zwsp} +

[[movies_in_container_site]]
It's important that *the new movies are inside/under _one common container item_ in the content hierarchy*. It's easiest for this lesson if the movie items are just directly under the site itself:

[.thumb]
image:add_movies.png[title="Create some movie items to list, under the site", width=1024px]

{zwsp} +

When you mark/preview the site itself, you'll see no visualization yet. But previewing each movie item should now work as in the image above.

Now we're ready to move on to more interesting stuff, using the content and code we just made.


{zwsp} +
{zwsp} +
{zwsp} +


== Static movie list

Next, we'll make a page controller for a site item that displays a static list of the _movie_ items below it. The controller will use a configurable guillotine query to fetch an array of movie data items.

{zwsp} +

[[guillotine_helpers]]
=== Guillotine helpers and usage

First off, an introduction to the guillotine helpers at we'll be using. Two of them are included in the react4xp starter, and the third one we'll write next.

==== Helpers included the react4xp starter

Included with the react4xp starter are *two general-purpose helpers*.

The central one and the first one we'll use, is *_headless/guillotineApi.es6_*. If we strip away a little boilerplate, the bare essence of it looks like this:

.headless/guillotineApi.es6:
[source,javascript,options="nowrap"]
----
const guillotineLib = require('/lib/guillotine');
const graphQlLib = require('/lib/graphql');

const SCHEMA = guillotineLib.createSchema();

const executeQuery = (query, variables) =>         <!--1-->
    graphQlLib.execute(SCHEMA, query, variables);



// Use in XP controllers:
exports.executeQuery = executeQuery;                <!--2-->


// Expose and use in POST requests from frontend:
exports.post = req => {                             <!--3-->
    var body = JSON.parse(req.body);

    return {
        contentType: 'application/json',
        body: executeQuery(body.query, body.variables),
        status: 200
    };
};
----

<1> At the core is the function `executeQuery`. Here, a guillotine `SCHEMA` definition is combined with a graphQL `query` string and an optional `variables` object. These are used with XP's graphQL library to `execute` the query. The result, a JSON object, is returned.
<2> `executeQuery` is exposed and directly usable from an XP controller. That's what we'll do next.
<3> a `post` function is also included for receiving POST requests from outside, e.g. a browser. If these requests contain a query string, it's executed with `executeQuery` above, and the result is returned in a response: basically a complete guillotine API endpoint for your webapp.

NOTE: This endpoint is *disabled by default* in the starter, to encourage developers to consider security aspects before using it. We'll get back to that, and activate it, <<#expose_api, later>>.



The second included helper, *_headless/guillotineRequest.es6_*, is a `fetch` wrapper to simplify guillotine requests at the frontend. We'll take a look at that <<#frontend_request, later>>.

==== Domain-specific helper for listing movies

In order to make requests for a list of movies below a container item in the content hierarchy, we'll need a specific guillotine query string, as well as functionality to adapt the resulting data into the proper props structure for the react components.

And by using the same code on the frontend and backend, for this too, we gain a bit of isomorphism (the predictability of a singe source of truth, in short). So we'll make *a module with custom helper functionality* for our use case, and import from it in both places:

.headless/helpers/movieListRequests.es6:
[source,javascript,options="nowrap"]
----
// Used by both backend and frontend (the movie-list part controller, and react4xp/entries/MovieList.jsx)

             <!--1-->
export const buildQueryListMovies = () => `
query(
    $first:Int!,
    $offset:Int!,
    $sort:String!,
    $parentPathQuery:String!
) {
  guillotine {
    query(
        contentTypes: ["com.enonic.app.react4xp:movie"],
        query: $parentPathQuery,
        first: $first,
        offset: $offset,
        sort: $sort
    ) {
      ... on com_enonic_app_react4xp_Movie {
        _id
        displayName
        data {
          year
          description
          actor
          image {
            ... on media_Image {
              imageUrl(type: absolute, scale: "width(300)")
            }
          }
        }
      }
    }
  }
}`;

             <!--2-->
export const buildParentPathQuery = (parentPath) => `_parentPath = '/content${parentPath}'`;


// Not using util-lib, to ensure usability on frontend
const forceArray = maybeArray => Array.isArray(maybeArray)
    ? maybeArray
    : maybeArray
        ? [maybeArray]
        : [];

             <!--3-->
export const extractMovieArray = responseData => responseData.data.guillotine.query
    .filter( movieItem => movieItem && typeof movieItem === 'object' && Object.keys(movieItem).indexOf('data') !== -1)
    .map(
        movieItem => ({
            id: movieItem._id,
            title: movieItem.displayName.trim(),
            imageUrl: movieItem.data.image.imageUrl,
            year: movieItem.data.year,
            description: movieItem.data.description,
            actors: forceArray(movieItem.data.actor)
                .map( actor => (actor || '').trim())
                .filter(actor => !!actor)
        })
    );

export default {};
----
<1> The function `buildQueryListMovies` returns a string: a *guillotine query* ready to use in the API. Colloquially, you can read this query in 3 parts:
+
- The parenthesis after the first `query` declares some parameters that are required (`!`) as values in a `variables` object together with the query.
+
- In the parenthesis after the second `query`, those `variables` values are used: this query will list a certain number (`$first`) of movie items (`contentTypes: ["com.enonic.app.react4xp:movie"]`), starting at index number `$offset`, and sort them using the sort expression string `$sort`. It narrows down the search by nesting a second and specifying query expression `$parentPathQuery`, that tells guillotine to only look below a certain parent path in the content hierarchy - see below (2.).
+
- The last major block, `... on com_enonic_app_react4xp_Movie {`, asks for a selection of sub-data from each found movie item: `_id`, `displayName`, `data.year`, etc. Note the second `... on media_Image` block nested inside it: instead of returning the ID value in the `data.image` field, we pass that through an `imageUrl` function that gives us a finished `data.imageUrl` field instead - directly and in one single query.
+
NOTE: Again, remember that this query hardcodes qualified names to a content type, that contain the name of the app: `com.enonic.app.react4xp:movie` and `com_enonic_app_react4xp_Movie`. Change these if your app name is not `com.enonic.app.react4xp`.
+
For more about the query language, see the link:https://developer.enonic.com/docs/headless-cms/2.x/api[guillotine API documentation].
<2> The function `buildParentPathQuery` returns a *sub-query string* needed to only search below the content path of a container item: the parameter `$parentPathQuery` in the main query string (1.), inserted through the `variables` object.
+
In <<#movies_in_container_site, the example above>>, the site _MovieSite_ is the item that contains the movies, and the content hierarchy in Content Studio shows us that _MovieSite_ has the content path `/moviesite`. So the sub-query that directs guillotine to only search for movies below that parent item, can be made like this: `buildParentPathQuery('/moviesite')`.
<3> The function `extractMovieArray` takes the data object of a full guillotine search result and adapts it to the data structure that matches the props structure of our react components: an array of objects, where each object is a movie item.

{zwsp} +

=== Part controller

Armed with these helpers, we can build an XP part controller that runs a guillotine query, extracts movie props from it, and renders a list of movies. We can even let the part's config control how the movies are listed:

.site/parts/movie-list/movie-list.xml
[source,xml,options="nowrap"]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<part>
    <display-name>Movie List</display-name>
    <description>View a list of movies</description>
    <form>

        <input name="movieCount" type="Long">
            <label>Number of movies to display</label>
            <occurrences minimum="1" maximum="1"/>
            <config/>
            <default>5</default>
        </input>

        <input name="sortBy" type="RadioButton">
            <label>Sort movies by...</label>
            <occurrences minimum="1" maximum="1"/>
            <config>
                <option value="displayName">Title</option>
                <option value="data.year">Release year</option>
                <option value="createdTime">Date added to this db</option>
            </config>
            <default>createdTime</default>
        </input>

        <input  name="descending" type="CheckBox">
            <label>... in descending (reversed) order</label>
        </input>
    </form>
</part>
----

The actual controller:

.site/parts/movie-list/movie-list.es6:
[source,javascript,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

const guillotine = require('/headless/guillotineApi');  <!--1-->
const { buildQueryListMovies, buildParentPathQuery, extractMovieArray } = require('/headless/helpers/movieListRequests');


exports.get = function(request) {
    const content = portal.getContent();
    const component = portal.getComponent();

    const sortExpression = `${component.config.sortBy} ${     <!--2-->
        component.config.descending ? 'DESC' : 'ASC'
    }`;

    const query = buildQueryListMovies();                     <!--3-->

    const variables = {                                       <!--4-->
        first: component.config.movieCount,
        offset: 0,
        sort: sortExpression,
        parentPathQuery: buildParentPathQuery(content._path)
    };

    const guillotineResult = guillotine.executeQuery(query, variables);     <!--5-->

    const movies = extractMovieArray(guillotineResult);         <!--6-->

    return React4xp.render(
        'MovieList',
        {                                                       <!--7-->
            movies,
            apiUrl: `./${portal.getSite()._path}/api/headless`,
            parentPath: content._path,
            movieCount: component.config.movieCount,
            sortExpression
        },
        request
    );
};
----
<1> Import the functionality from the helpers that were <<#guillotine_helpers, just described>>,
<2> Use the part's config to build a sort expression for the query,
<3> Get the query string,
<4> Build the `variables` object with the query's parameters,
<5> Execute the query string with the variables in the guillotine API,
<6> Extract `movies` props (an array of objects with the same signature as the props for _Movie.jsx_) from the result of the query,
<7> Render a _MovieList_ entry with the `movies` props (as well as some additional props that we will need later for making the same guillotine query from the frontend. Especially note the `apiUrl` prop: this is basically just the URL to the site itself, with `/api/headless` appended to it. When we later <<#expose_api, expose the guillotine API>> to the frontend, this is the URL to the API - specifically, the POST method in _guillotineApi.es6_).

{zwsp} +

=== React components

We're still missing that *_MovieList_ entry* that will display the list of movie items:

.react4xp/myEntries/MovieList.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react'

import './MovieList.scss';

import Movie from "../shared/Movie";

const MovieList = ({movies, apiUrl, parentPath, movieCount, sortExpression}) => {

    return (
        <div className="movieList">
            {movies
                ? movies.map(movie =>
                        <Movie key={movie.id} {...movie} />
                    )
                : null
            }
        </div>
    );
};

// MUST use this export line wrapping, because of a useState hook later.
export default (props) => <MovieList {...props} />;
----
The only notable things here:

- A lot of the props aren't used yet, just the `movies` array. The rest of the props are a preparation for later.
- Each item object in the array in `movies` is just mapped onto an imported _shared/Movie.jsx_ component: the same react component that's used to render the movie previews in Content Studio.

Most of the styling is already handled at the single-movie level, so just a minimum of extra *list styling* is needed:

.react4xp/myEntries/MovieList.scss:
[source,sass,options="nowrap"]
----
.movieList {
  margin: 0 auto; width: 1024px; max-width: 100%;

  .movie {
    border-bottom: 1px dotted #ccc;
  }
}
----

{zwsp} +

=== Render the list

We can now set up the parent site with the movies, with a _movie-list_ part. Rebuild the app, enter/refresh Content Studio, and make the _movie-list_ part handle the visualization of the _MovieSite_ item.

TIP: You can either do that <<pages-parts-and-regions#adding_parts_to_new_content, with a template as before>> to render _all_ sites with this part controller. Or better, edit _MovieSite_ directly  and add the _movie-list_ part to the region there, the same way as when adding a part to the region of a template. With this last direct-edit approach, only _MovieSite_ will be rendered like this; other sites won't.

Correctly set up, you can now select the list in the edit panel, and a part config panel will appear on the right. *Edit the config fields to control the guillotine query*: how many movies should be rendered, and in what order?

[.thumb]
image:movie-list-part-config.png[title="Edit the movie-list part configuration to control the guillotine query", width=1024px]

{zwsp} +

TIP: As usual, click Preview to see the rendering in a tab of its own. A preview browser tab, with the page inspector and server log open on the side, is also the best starting point to hunt down bugs in the visualization.

{zwsp} +
{zwsp} +
{zwsp} +

== Making the list dynamic

{zwsp} +

[[expose_api]]
=== Exposing the guillotine API

Blah

{zwsp} +

[[frontend_request]]
=== Frontend guillotine request

{zwsp} +

=== Dynamic DOM updates

{zwsp} +

=== Scroll listener

{zwsp} +

=== Ad infinitum

Refresh the preview of _MovieSite_, and there you have it: the infinite scroller. Scroll down to auto-refresh with new content, until the very end of time or the end of your added movies, whichever comes first.


{zwsp} +
{zwsp} +
{zwsp} +

== Other resources and tools

TIP: This section is not a vital part of the rest of this or the next chapter. Feel free to skip it and miss out.

To dive deeper into guillotine and graphQL, you can always check out the link:https://developer.enonic.com/templates/headless-cms[headless starter].

=== GraphQL playground

There is a handy tool in the headless starter, that we might as well add here too: the GraphQL Playground.

The GraphQL Playground is basically an in-browser *GraphQL REPL interface*. It allows you to send queries and variables to the frontend API and see the results immediatly: experiment around, get to know guillotine, and build queries more effectively.

To add this, first add the _graphql-playground_ library as a dependency in _build.gradle_:

.<project root>/build.gradle:
[source,groovy,options="nowrap"]
----

// (...)

dependencies {
    // (...)

    // Add this under dependencies:
    include "com.enonic.lib:lib-graphql-playground:0.0.1"
}
----

Next, copy this code in at the end of _headless/guillotineApi.es6_:

.headless/guillotineApi.es6:
[source,javascript,options="nowrap"]
----

// ----------------------------------  Graphql playground, at the same URL as the API  -----------------

var graphqlPlaygroundLib = require('/lib/graphql-playground');
var authLib = require('/lib/xp/auth');

// GraphQL playground
exports.get = function (req) {
    if (req.webSocket) {

        return {
            webSocket: {
                subProtocols: ['graphql-ws']
            }
        };
    }

    // Simple auth control for the playground
    if (!authLib.hasRole('system.authenticated')) {
        return {
            status: 401,
            body: {
                "errors": [ {"errorType": "401", "message": "Unauthorized"} ]
            }
        };
    }
    if (!(authLib.hasRole('system.admin') || authLib.hasRole('system.admin.login'))) {
        return {
            status: 403,
            body: {
                "errors": [ {"errorType": "403", "message": "Forbidden"} ]
            }
        };
    }

    var body = graphqlPlaygroundLib.render();
    return {
        contentType: 'text/html; charset=utf-8',
        body: body
    };
};

----

That's it. Remember that <<#expose_api, the controller mapping exposes _guillotineApi.es6_>> on the URL `/api/headless` below sites that use this app? We just added a GET response method there, so now if you...

- rebuild your project,
- enter Content Studio again,
- select your movielist site,
- preview it,
- and then add `/api/headless` after the URL in the preview tab (e.g. `http://localhost:8080/admin/site/preview/default/draft/moviesite/api/headless`),

...the playground should be rendered up and running and ready for you to explore:

image:graphql-playground.png[title="The GraphQL playground", width=1024px]




=================================
----

The Part definition enables two editorial configurations:

.site/parts/multi-color/multi-color.xml:
[source,xml,options="nowrap"]
----

----


.site/parts/multi-color/multi-color.es6:
[source,javascript,options="nowrap"]
----

----


{zwsp} +

=== React component

.react4xp/myEntries/MultiColor.jsx:
[source,javascript,options="nowrap"]
----
----

{zwsp} +

=== Dependencies for the entry

==== Styling

.react4xp/myEntries/MultiColor.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

.react4xp/shared/shared-styles.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

==== Imported react components

{zwsp} +

===== Button

.react4xp/shared/Button.jsx:
[source,javascript,options="nowrap"]
----

----

.react4xp/shared/Button.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

===== ActiveColorOval

.react4xp/shared/ActiveColorOval.jsx:
[source,javascript,options="nowrap"]
----

----

.react4xp/shared/ActiveColorOval.scss:
[source,sass,options="nowrap"]
----

----

{zwsp} +

===== ColorButtons

.react4xp/shared/ColorButtons.jsx:
[source,javascript,options="nowrap"]
----

----

.react4xp/shared/ColorButtons.scss:
[source,sass,options="nowrap"]
----

----


{zwsp} +

[[webpack_config]]
== Configuring react4xp and webpack

In this section we'll adjust some settings to make the code above work.

TIP: Some of this is covered in more detail under <<entries#, entries>> and <<jsxpath#, jsxPaths>>.

{zwsp} +

=== Folders for entries and chunks

.react4xp.properties:
[source,properties,options="nowrap"]
----

----

[NOTE]
====

====

{zwsp} +

=== Adding webpack rules

.react4xp.properties:
[source,properties,options="nowrap"]
----

----

.webpack.config.react4xp.js:
[source,javascript,options="nowrap"]
----

----

{zwsp} +

==== NPM dependencies


[source,bash,options="nowrap"]
----

----

{zwsp} +

== Setup and rendering


.Empty multicolor Part:
image:multicolor-add.png[title="Empty MultiColor part in Content Studio", width=720px]

{zwsp} +


.Multicolor Part with colors filled in:
image:multicolor-added.png[title="MultiColor part in Content Studio, with four colors added", width=720px]

{zwsp} +


.Multicolor Part, active view:
image:multicolor-preview.png[,title="MultiColor part outside of Content Studio, active view after clicking the #5d0015 button", width=720px]

{zwsp} +


== Output

.Page source from the Multicolor Part, active view (serverside rendered not selected):
[source,html,options="nowrap"]
----

----

{zwsp} +

== Further reading

-> <<entries#, Entries>>

-> <<jsxpath#, JsxPath>>

-> <<chunks#, Dependency chunks>>

{zwsp} +

<<api#, API>> reference:

-> <<api#react4xp_render, React4xp.render>>

-> <<api#react4xp_object, React4xp data objects>>

{zwsp} +
{zwsp} +

----


The link:https://iconscout.com/icons/movie[movie icon] that marks the _movie_ content type in the screengrabs is by link:https://iconscout.com/contributors/phoenix-group[Phoenix Dungeon] on link:https://iconscout.com[Iconscout].
