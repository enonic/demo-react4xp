= React4XP: Entries, jsxPath and dependency chunks
:toc: right
:toclevels: 2
:imagesdir: media/

== Back to:

====== link:index.html#introduction[Introduction]
====== link:index.html#_next_basic_lessons[Basic lessons]
====== link:index.html#_advanced_lessons[Advanced lessons]

== {zwsp} +

{zwsp} +
{zwsp} +

[[entries_and_jsxpath]]
image:react4xp.svg[title="React4xp logo",width=256px]

{zwsp} +

== ENTRIES, JSXPATH AND DEPENDENCY CHUNKS

For reference, here are some more details about what _entries_ and their _jsxPath_ are, and how they relate to a way of optimizing performance: dependency chunks

[[entries]]
{zwsp} +

=== Entries

====
React4xp is structured around _entries_. An entry is just *a React component that can be accessed by react4XP* in an XP controller. They are the _only_ react files that react4xp can use directly!

{zwsp} +

Entries are pretty much just standard JSX files, but they must follow *two requirements* (link:media/entries_howto.png[cheatsheet]):

1. *default-exports a function*, this function _may_ take a `props` argument (serializable JS object) and _must_ return a react component (pure functional component or old-school React Component), and
2. is located either in a folder either below *_/site/_* or below one of the *entryDirs* folders listed in _react4xp.properties_ (see also _jsxPath_ below).

{zwsp} +

Think of *entries as "bridge elements"*:

.A mental model (image links to another cheatsheet):
image:entries.png[link="media/entries_cheatsheet.png",title="React4xp Entries basic structure. Controllers can use entries, entries can import anything", width=600px]

On the XP/server side, you have the controllers with their backend XP flow, logic and XP lib imports. Entries are the beginning of the frontend side (although the same code is also used for serverside-rendering): they do regular frontend-style ES6 logic and can *import* stuff from NPM/node_modules, your own logic, nested react components, whatever - even other entries.

{zwsp} +

React4xp handles them in build-time and runtime: locates entries, compiles them into *entry assets* (under _/build/resources/main/assets/react4xp_), and serves them to the client.

Each entry becomes a separate *root level react app*. Good to know if you display more than one entry on a page - which you can, but you might also consider using just one entry for the root, and multiple imports in it.

For example, earlier in this tutorial we've seen the entries _hello-react.jsx_ and _color.jsx_, they are compiled into the assets _hello-react.js_ and _color.js_.
====

{zwsp} +

[[jsxPath]]
{zwsp} +

=== JSX Path

====
Each entry is identified by its own _jsxPath_.

Short and brutal: the jsxPath is a name string generated from the path and filename of the compiled asset after building, relative to _/build/resources/main/assets/react4xp/_ - without file extension.

During development though, these *3 rules* are probably easier:

1. If you use the `component` object like in link:#hello_react_page[the first example], you can ignore the jsxPath. `React4xp.render` will use the component object to find an entry with the same folder/same name as a part/page/layout controller.

But if you need to access an entry from a different folder - from anywhere actually - here's *how to find the jsxPath of an entry*:

[start=2]
2. If an entry's source file is a JSX under _/src/main/resources/_ *_site/_*, the jsxPath is the source file's path relative to _/src/main/resources/_ - unix-style and without file extension.
* So the jsxPath will start with `site/...` etc (and the asset will be compiled into a folder below _/build/resources/main/assets/react4xp/_ *_site/_*, and so on).
3. Or, using the setup from the starter, you can also put your entries under _src/main/resources/_ *_react4xp/entries_*. Then the jsxPath (and compiled-asset path) will be relative to _/entries/_ instead.
* Actually, you can control this with the `entryDirs` property in _react4xp.properties_. The starter has added `entryDirs=entries` here, but this is a comma-separated list of folder names relative to _src/main/resources/react4xp/_. Remember, if you add more entryDirs or replace `entries`, the jsxPaths will always be relative to those new entryDirs.

* *For example:* add `../myComponents` to entryDirs: `entryDirs=entries,../myComponents`. Since entryDirs and the "../" are relative to _src/main/resources/react4xp/_, the new entry source folder is _src/main/resources/myComponents/_. Now new JSX files can be put there, and get a jsxPath relative to that. So the entry _src/main/resources/myComponents/_ *_app/myEntry.jsx_* will get the jsxPath `"app/myEntry"`, and will be compiled to the entry asset _/build/resources/main/assets/react4xp/app/myEntry.js_.

If you're ever unsure: after building, all the *jsxPaths of all the available entries* are stored in _build/resources/main/assets/react4xp/entries.json_. This file is generated by webpack during build. It's also used by the runtime, so it shouldn't be deleted or edited!

NOTE: jsxPaths are not actually file system paths, but *static name strings*. So avoid shortcuts and relative references like `../`, etc.

See also: the link:#chunks[chunks] info box.
====

{zwsp} +

[[chunks]]
{zwsp} +

=== Dependency chunks

To summarize and reiterate a few of the things we've looked at around dependency chunks and how to use them:

====

*A dependency chunk is a compiled asset that contains (usually a collection of multiple) components that are used at runtime*. Think of it as a library of secondary resources. Dependency chunks are served by react4xp to the client and used there. They may contain JS, or other types of code.

Entries and other chunks can import resources from chunks using *ordinary ES6 imports*, as long as the necessary webpack rules are added. Compilation rules for ES6 and JSX are included with react4xp, the rest must be custom added - see link:#imports_chunks[example 6].

{zwsp} +

.Entries and chunks - the full picture:
image:entries_and_chunks.png[link="media/entries_and_chunks.png", title="Controllers, entries and chunks visualized together. Click for larger version.", width=720px]

See also: the link:#entries_and_jsxpath[entries and jsxPath] info boxes.

{zwsp} +

In the standard react4xp setup, two chunks are likely to appear without any further setup: *externals and vendors*. That is, their names are hashed and will appear as `externals.<hash>.js` and `vendors.<hash>.js`.

- Externals usually contains react and react-dom, ensuring that the same react version is used when rendering on the client and server.
- Vendors is the chunk for anything else imported from _node_modules_.

You can also *define your own dependency chunk structure*. Additional folders (relative to _src/main/resources/react4xp/_) can be defined with `chunkDirs` in _react4xp.properties_. This will cause all source files under each chunkDir to be compiled into one common dependency chunk (or to be precise: one chunk for each codetype defined by webpack rules, e.g. separate JS and CSS chunks).

- The asset's name will be the name of the parent folder, with a content hash: <chunkName>.<hash>.<extension>.
- For example, adding `chunkDirs = foo/bar` under _react4xp.properties_, adding _hey.js_ and _baz/ho.js_ and importing stuff from _hey_ and _ho_ in an entry, will create the dependency chunk _bar.<hash>.js_ - which contains both _hey_ and _ho_.

{zwsp} +

What happens if an entry imports something from folders *not marked as chunkDirs*?

- Importing an entry into anonther entry is possible, and leaves both entries compiled and handled as regular entries.
- Imported JS (react components etc) from non-entry folders will be *compiled into the entry asset* itself. Try to avoid this, since the entries can become bloated, and code can become repeated if it's imported into more than entry. The entry assets are also less performance optimized.
- Non-JS imports (CSS etc), are compiled to separate assets under their own name, the same way as entries (but are not given a _jsxPath_, of course).

{zwsp} +

Dependency chunks never contain link:#entries[entries]; each entry is an asset file of its own. Consequently, nothing inside a dependency chunk will have a jsxPath. This is why entries are used as a separate word from react components: all entries are react components, but react components can also be secondary imports from chunks / chunkDirs. Only entries are runtime-available to react4xp.

{zwsp} +

Chunks are handy for collecting related secondary resources (that may be frequently used together in one part of a site but not others, for instance - making it possible to minimize the necessary client downloads). But most importantly, they are automatically *optimized for performance*:

- They are both cached on the server side as well as in the client - preventing repeated generation and minimizing downloads, speeding up the site.
- The hash is updated by content, for effective cache busting.
- Even if the resources in a chunk are used more than once on a page, the chunk is only downloaded once.

{zwsp} +

*Recommended usage:* chunks are made to be *fire-and-forget*. Define the chunkDir, some webpack rules if necessary, and import it from your entry (or your secondary components inside chunks) - react4xp will handle the rest. Dependencies are tracked, so `React4xp.render` (and `.renderPageContributions`) automatically adds extra client-side links to necessary chunks.

Since chunks are most optimized for repeated usage, it's best to put your heavy components and resources in chunks, and *let the entries stay slim and lightweight*.

====


== {zwsp} +

== More details and API

====== link:faq.html#faq[FAQ]

{zwsp} +

====== link:api.html#_react4xp_render[React4xp.render]

{zwsp} +
{zwsp} +
