= Server side JSX with React4XP
:toc: right
:toclevels: 1
:imagesdir: media/


[NOTE]
====
**UPDATED {docdate}:** multiple adaptations for starter and lib version 1.0.0.

This documentation expects basic knowledge of React, XP and Webpack.

* https://reactjs.org/tutorial/tutorial.html[the official intro to React]
* https://developer.enonic.com/start[the Enonic XP developer portal].
* https://webpack.js.org/guides/getting-started/[webpack documentation].


====



== Introduction

This tutorial will show you step-by-step how to build XP sites and apps with React rendering, helping you kickstart a React4xp project of your own.

During this exercise you will:

- set up the starter and meet the React4xp library,
- learn how to use it to render a basic React component from any regular XP controller,
- inject editorial data into your React component,
- see how to point the controller to the React components - and where to put them in your project source,
- dig a little deeper into ways of controlling the rendering,


== React4XP

image:react4xp.svg[title="React4xp logo",width=256px]

This starter is based on *React4XP*, which is a library (with a companion build structure) that facilitates use of React in Enonic XP, and:

* enables you to use JSX as a templating language, similar to other XP templating engines
* supports isomorphic client- or serverside rendering and hydration,
* handles build flow and compilation with automated optimized asset serving
* is modular and tweakable, making it possible to pop the hood, pick it apart and set things up your own way. Godspeed!
* is flexible enough to cover many advanced use cases,


== Setup

=== Create project

Set up the starter project locally. With Enonic XP 7, run the following command:

[source,bash]
----
enonic project create -r starter-react4xp
----

Remember to create a *new XP sandbox* when completing the project wizard.

[TIP]
====
*Don't have the Enonic CLI?* Visit the https://developer.enonic.com/start[Getting started guide] to install it.

*Only want to inject react4xp into your own XP project?* The https://github.com/enonic/lib-react4xp/blob/master/README.md[lib-react4xp docs] have a section on how to do without the starter. But it's recommended to go through this introduction first.
====


=== Project structure

If you're used to working with a typical XP project using https://developer.enonic.com/templates/webpack[webpack], the structure in your project root folder will now look familiar -
the biggest news is `react4xp.properties` and the folder `resources/react4xp/`.

TIP: This is just an overview, no need to know it by heart to get started - we'll get back to all of these in more detail. For the most impatient, the takeaway is: *put your JSX source files somewhere below `react4xp/entries/` or `site/`*.

[source,files]
----
build.gradle                <--1-->
gradle.properties
settings.gradle
package.json

react4xp.properties         <--2-->

src/
  main/
    resources/
      react4xp/             <!--3-->
        entries/
        shared/

----

<1> A set of gradle config files and `package.json`. These define the build process and project structure, and in particular, make sure that the *lib-react4xp library* and *react4xp npm package* are installed right.
<2> `react4xp.properties`: tune the most common properties of the react4xp project.
<3> The `react4xp/` folder is opt-in: can be ignored for now, and doesn't need to contain anything. But when fine-tuning the build later in the tutorial, we'll get back to why you might find it handy to have a separate place for some of your react components (in ultra-short: the `entries\` folder is for react components that can be used directly by react4xp, the `shared\` folder is for common components imported by, and shared between, the entries).



=== Build and Deploy

To build and deploy the starter app, run this command from your shell:

[source, bash]
----
enonic project deploy
----

Accept starting the sandbox.

[NOTE]
====
To verify that your app started successfully, you should find an entry similar to this in the sandbox log:

`2019-04-09 13:40:40,765 INFO ... Application [<name.of.your.app>] installed successfully`
====

{zwsp} +
{zwsp} +

Now you're ready to get started with the *6 example lessons* - starting from the basics:

- link:#hello_react_page[1: Hello React: server and clientside]
- link:#editorial_props[2: Editorial props]
- link:#xp_pages_parts[3: XP pages, parts and regions]
- link:#free_structure[4: Free source file structure]
- link:#custom_flow[5: Custom flow]
- link:#imports_chunks[6: Imports and dependency chunks]


{zwsp} +
{zwsp} +

[[hello_react_page]]
== 1: Hello React: server and clientside

React4xp is made to cover many ways of combining XP and react. Let's start with a simple scenario: just displaying a working react component in content studio. We'll first do that in the serverside rendered way (this is the react4xp default). And afterwards add an option flag that turns the rendering into clientside-rendering instead.

We'll do this by adding a regular XP page controller we'll call _hello-react_:

.Files involved:
[source,files]
----
site/pages/hello-react/
  hello-react.xml
  hello-react.jsx
  hello-react.es6
----

These files are not included in the starter - use your copy/paste skills and remember that `hello-react` must be identical between file names and folder name.

=== Code

First, we need a *page definition* XML file. Just XP boilerplate:

.hello-react.xml:
[source,xml,linenums,options="nowrap"]
----
<page>
  <display-name>Hello React</display-name>
  <description>Super simple example</description>
  <form />
</page>
----

Next, we'll add the *react component*. This displays a "Hello world" heading, and we'll add some simple functionality to it: every time you click the message, it will update a number in the next line and print a message in the console. This is to show that we're rendering an _active_ react component; we're not only using JSX as an XP templating language for static HTML - although sure, you could do that too if you want.

Obviously, the actual updating step is done with vanilla JS instead of actual react, just to keep everything as simple as possible. We'll look at stateful/dynamic components later.

.hello-react.jsx
[source,javascript,options="nowrap"]
----
import React from 'react';

let bottleCount = 99;
function dropBottle() {
    bottleCount--;
    console.log(bottleCount, 'bottles of beer on the wall.');
    document.getElementById('counter').innerText = bottleCount;
};

export default (props) => <div onClick={dropBottle}>
    <h1>Hello world!</h1>
    <p>Click me: <span id="counter">{bottleCount}</span> bottles of beer on the wall.</p>
</div>;
----

[NOTE]
====
One thing is mandatory for this to work, shown in the last line: the JSX file *must default-export a function* that *_may_ take a props object* and *_must_ return a react component*. More on this link:#entries[later].

Apart from that, you can use ordinary ES6 and import and nest other JS, react components and third-party stuff from node_modules in the regular way (there is a caveat or two here. We'll get back to that too later).
====
Finally, we'll add a bare-bone *page controller* that calls the rendering engine:

.hello-react.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');       // <1>

exports.get = function(request) {                       // <2>
    const entry = portal.getComponent();                // <3>
    const props = null;

    return React4xp.render(                             // <4>
        entry,
        props,
        request,
        {
            id: "react4xpApp",                          // <5>
            body:                                       // <6>
                `
                    <html>
                        <head></head>
                        <body class="xp-page">
                            <div id="react4xpApp"></div>
                        </body>
                    </html>
                `
        }
    )
};
----




That's it.

If you've used XP before, you'll probably note that there's no HTML view file, no `thymeleaf.render`, and so on - in this example, react4xp completely handles the page view. The essential thing here is that at the end of the `get` function, *react4xp in a single _.render_ call creates a _full_ XP response object that makes react work.*

What's going on in the controller?

<1> In line 2, `React4xp` is imported from the library.
<2> In line 4, we pick up the `request` data. The render call needs it to know the rendering context.
<3> In line 5, we get the XP component data. Used directly in the `.render` call, it's a convenient shortcut for react4xp to "this XP component", for finding the same-name react component in the same folder: _hello-react.jsx_. React4xp has more ways to refer to react components, or _entries_ (we'll get to that under link:#_react4xp_render[the render call] and link:#jsxPath[jsx paths]).
<4> In line 8, the juicy bit: *the actual render call*. The rendered response from it can be returned directly from the `get` function, since `.render` creates an object with a `body` HTML string and a `pageContributions` attribute with everything needed (more about this link:#_react4xp_render[below]).
<5> In line 13, the `id` attribute _"react4xpApp"_ is set in the *options* argument of `.render` (lines 12-20). This is the unique ID we're giving to the react component, and the HTML id of the target element where react will render the component in the end. Note that the same ID is found in an element in the HTML `body`:
<6> In lines 14-19, we're hardcoding a `body` option, an HTML string as a base for the output, with a _"react4xpApp"_ ID element. In many cases you can do without this string but here it's needed for the output, since react itself doesn't like to render the tags `<html>`, `<head>`, `<body>` or anything outside of a containing root tag (such as `<!DOCTYPE html>`).

[[first_setup_render]]
=== Setup and first render

If you've added those 3 files, let's get this rendered!

1. Compile the project (`enonic project deploy` in a terminal from root) and start the sandbox (`enonic sandbox start`),
2. Navigate your browser to `localhost:8080/admin`. Log in to XP and open Content Studio (if you haven't already, you'll need to link:https://market.enonic.com/vendors/enonic/content-studio[install Content Studio] in XP).
3. Create a new site and edit it. Use the new _Hello-react_ page controller, store that change. You should now see something like this:

[.thumb]
image:hello_cs.png[title="Editing in Content Studio: Hello World. Click to see a high-res version", width=1024px]

{zwsp} +

[start=4]
4. Click _Preview_ on the top to open a new tab and view the content outside of Content Studio:

[.thumb]
image:hello_bottles.png[title="Rendering: Hello World and some bottles on a wall somewhere. Bet you clicked this screenshot, didn't you?", width=768px]

{zwsp} +

Clicking somewhere on the rendered text in the preview window will trigger the `dropBottle` function from _hello-react.jsx_, and modify the DOM and output a message in the browser console. Look at those bottles go!

{zwsp} +

[[static_cs_rendering]]
==== Two notes on the rendering before we move on:
====
*STATIC RENDERING IN CONTENT STUDIO*

If you clicked the rendering _inside XP Content Studio_ instead of a preview tab, you'd notice there was *no bottle-counting*. This is on purpose: react functionality may intervene with the Content Studio editorial workflow, or even disrupt Content Studio itself. Therefore, the `request` argument is used in `React4xp.render` to handle this automatically: inside Content Studio, you'll only see the rendering as a regular static XP preview / placeholder instead of active react.

NOTE: Later, we'll look at two other rendering functions: `.renderBody` and `.renderPageContributions`. These are intended for use cases where it's good to be more explicit than `React4xp.render`. For that reason, they _don't automatically handle this for you_. Usually, you should still keep your components from being client-activated inside Content Studio, but you'll have to handle it yourself. link:#custom_flow[Example 4 shows you how].
====

====
*SLOW FIRST SERVERSIDE RENDERING*

You may also have noticed that it took a few seconds for the very first rendering to be displayed, either here or in the edit/browse mode in Content Studio. That's the *Nashorn server-side rendering engine warming up*. It reads and caches the basics (notably, some necessary polyfilling, react and react-dom) for performance.

We're looking into mitigating this delay in the future, but for now, this is nice to know: *This delay only happens when your app is restarted*, i.e. you restart XP entirely, or redeploy the app. Setting up a continuous build with XP devmode instead, helps. For the react4xp starter, here's how:

`enonic sandbox start <yourSandBoxName> --dev` in one terminal (from anywhere), and

`enonic project deploy && gradlew react4xp_components compileXP -t` from project root in another terminal. Reply _No_ if it asks you to start the sandbox here.
====


[[hello_output]]
=== Output

Okay, back to the rendering of the page -? Open the *page source* code in the browser. Here's what `React4xp.render` created - the response the client receives on the initial page request:

[source,html,options="nowrap"]
----
<html>
<head></head>
<body class="xp-page">

    <div id="react4xpApp">
        <div data-reactroot="">                     <!--1-->
            <h1>Hello world!</h1>
            <p>Click me: <span id="counter">99</span> bottles of beer on the wall. </p>
        </div>
    </div>

    <script src="(...your.app.service) /react4xp/externals.489d97cdf.js"></script>      <!--2-->
    <script src="(...your.app.service) /react4xp-client/"></script>                     <!--3-->
    <script src="(...your.app.service) /react4xp/site/pages/hello-react/hello-react.js"></script>  <!--4-->
    <script defer>
        React4xp.CLIENT.hydrate(                                                        <!--5-->
            React4xp['site/pages/hello-react/hello-react'],
            "react4xpApp",
            null,
            1, 0);
    </script>
</body>
</html>
----
We can see this whole output is actually the `body` HTML string we passed into the `React4xp.render` call in the controller - but *a lot has been inserted*. Most importantly, three assets are loaded into the client.

(The asset URLs are shortened for readability, and because some details may vary. At my computer for example, the `(...your.app.service)` part actually looks like: `/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/`)

<1> At the top, we see the `<div id="react4xpApp">` target container, now filled with a server-side rendering of the react component. At this point it's only static markup, but it will be activated during step 5 below.
<2> The first asset is `externals.<contenthash>.js`: this is react and react-dom bundled together. They are served from XP instead of from a CDN. If you want to read more about why, or how to tweak the externals, see the link:https://www.npmjs.com/package/react4xp-runtime-externals[externals docs on NPM].
<3> The second loaded asset is a client-wrapper, available in the browser's namespace as `React4xp.CLIENT`. For more, see the link:https://www.npmjs.com/package/react4xp-runtime-client[client wrapper docs on NPM].
<4> The third asset is the compiled version of _hello-react.jsx_, with the react component and the `dropBottle` routine. During `React4xp.render`, react4xp used the `component` data to locate this asset _after_ compiling. The react component gets an identifier string, `site/pages/hello-react/hello-react`, which is called a _jsxPath_ in react4xp. We'll link:#jsxPath[cover jsxPaths in more detail later], but for now you just need to know that this identifier is also used when loading this asset into the the browser's namespace: `React4xp['site/pages/hello-react/hello-react']`.
<5> Finally, the trigger. The CLIENT wrapper calls link:https://www.npmjs.com/package/react4xp-runtime-client#hydrate[hydrate] to activate react in the serverside-rendered asset `React4xp['site/pages/hello-react/hello-react']` in the target container `"react4xpApp"`. Now the `dropBottle` function works! We haven't added any props yet, hence the `null` argument. The final two digits `1, 0` are internal react4xp housekeeping, flagging some possible need for client-side postprocessing.

NOTE: The assets are served by lib-react4xp services. Most of them (_react4xp-client_ and the content-hashed assets) are optimized for client-side caching, to minimize repeated requests.


=== Client-side rendering

Sometimes you might want or need to skip the server-side rendering of a react component, and relay the react rendering entirely to the browser. This a one-line operation in `React4xp.render`. Let's return to *the controller*:


.hello-react.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const entry = portal.getComponent();
    const props = null;

    return React4xp.render(
        entry,
        props,
        request,
        {
            id: "react4xpApp",
            body:
                `
                    <html>
                        <head></head>
                        <body class="xp-page">
                            <div id="react4xpApp"></div>
                        </body>
                    </html>
                `,
            clientRender: true                          // <1>
        }
    )
};
----
<1> On the server, a truthy `clientRender` flag in the _options_ object makes the server skip the HTML rendering (in _this_ particular `.render` call. Mixing up clientside and serverside rendering across different places hasn't been tested very much, but it should work fine).

If you compare with link:#hello_output[the serverside-rendered example], the `clientRender` flag causes the *rendered output* to change slightly, changing the behavior in the browser.

[source,html,options="nowrap"]
----
<html>
<head></head>
<body class="xp-page">

    <div id="react4xpApp"></div>    <!--1-->

    <!--2-->
    <script src="(...your.app.service) /react4xp/externals.489d97cdf.js"></script>
    <script src="(...your.app.service) /react4xp-client/"></script>
    <script src="(...your.app.service) /react4xp/site/pages/hello-react/hello-react.js"></script>

    <script defer>
        React4xp.CLIENT.render(     <!--3-->
            React4xp['site/pages/hello-react/hello-react'],
            "react4xpApp",
            null,
            1, 0);
    </script>
</body>
</html>
----
<1> As expected, the target container is no longer filled with a serverside-rendered HTML representation of the react component. Instead, the browser fills in the DOM from scratch in step 3 below.
<2> The compiled assets and their URLs are exactly the same as in the serverside version.
<3> The trigger is changed: the `React4xp.CLIENT` wrapper calls link:https://www.npmjs.com/package/react4xp-runtime-client#render[render] and makes the browser build the DOM inside the target element from scratch (instead of calling `React4xp.CLIENT.hydrate`, which activates/replaces existing HTML). The function signatures of `React4xp.CLIENT.render` and `React4xp.CLIENT.hydrate` are identical.

NOTE: As link:#static_cs_rendering[mentioned before], this only applies _outside_ of Content Studio. The `clientRender` flag does not change anything inside Content Studio: still server-side rendered static HTML.

Apart from these differences behind the scenes, the page will look and behave the same when presented to the user.

Finally, it's worth mentioning a special case where you might want to _temporarily_ clientside-render a component:

[TIP]
====
You might get _serverside runtime errors_ in the react components that you write. The Nashorn rendering engine will dump an error message and some suspected code in the server log - but it's not always easy to make sense of those.

Often, switching over to _clientside rendering_ for that particular react component, will give you a better/sourcemapped error message in the browser console, making your debugging life easier.
====

Okay, ready for the next example lesson?

{zwsp} +
{zwsp} +

[[editorial_props]]
== 2: Editorial data and props

Here we'll spice up our react component a little bit by using `props` to insert editorial data from XP into the react component.

We'll modify the same files you created above:

.Files involved:
[source,files]
----
site/pages/hello-react/
  hello-react.xml
  hello-react.jsx
  hello-react.es6
----

=== Code

Now let's change the files some more so we can use Content Studio to input some data into the react rendering.

We start with some standard XP procedure: defining the data in the *page definition* XML file. This file is the same as in example 1, but we're adding a few link:https://developer.enonic.com/docs/xp/stable/cms/input-types[input fields] under `<form>`. `greeting`, `greetee`, `counted` and `startCount` are the basis for the initial props of the react component:

.hello-react.xml:
[source,xml,linenums,options="nowrap"]
----
<page>
  <display-name>Hello React</display-name>
  <description>Editorial example</description>
    <form>
        <input type="TextLine" name="greeting">
            <label>What's the greeting?</label>
            <default>Hello</default>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input type="TextLine" name="greetee">
            <label>Who shall we greet?</label>
            <default>world</default>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input type="TextLine" name="counted">
            <label>What are the things on the wall?</label>
            <default>bottles of beer</default>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input type="Long" name="startCount">
            <label>How many of them are there?</label>
            <default>99</default>
            <occurrences minimum="1" maximum="1"/>
        </input>
    </form>
</page>
----

Next, we'll modify the *react component* so that it displays data from a `props` object, instead of hardcoding everything.

.hello-react.jsx
[source,javascript,options="nowrap"]
----
import React from 'react';


function makeThingDropper(droppableProp, initialCountProp) {
    let currentCount = initialCountProp;
    return () => {
        currentCount--;
        console.log(currentCount.toString(), droppableProp, 'on the wall.');
        document.getElementById('counter').innerText = currentCount;
    };
}

export default (props) => {
    const dropThing = makeThingDropper(props.droppableThing, props.initialCount);
    return (
        <div onClick={dropThing}>
            <h1>
                {props.message} {props.messageTarget}!
            </h1>
            <p>
                Click me: <span id="counter">{props.initialCount}</span> {props.droppableThing} on the wall.
            </p>
        </div>
    );
}
----

[TIP]
====
`props` are of course the standard react way to do this. It all is. As long as a _props => reactComponent_ function is default-exported, react4xp accepts standard valid ES6/JSX.

Although, if you think that the _makeObjectDropper_ closure thing is a strange way to do something react itself could do better... I can't argue with that. Just trying to stay focused on one thing at a time.
====

And lastly, we'll hook them together: modify *the controller* to fetch the data we defined in XML, then use a `props` object to inject the data into the react component:

[[controller_with_props]]
.hello-react.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');


exports.get = function(request) {
    const entry = portal.getComponent();

    const content = portal.getContent();                    // <1>
    const pageConfig = (content.page || {}).config || {};

    const props = {                                         // <2>
        message: pageConfig.greeting,                       // <3>
        messageTarget: pageConfig.greetee,
        droppableThing: pageConfig.things,
        initialCount: pageConfig.startCount
    };

    return React4xp.render(
        entry,
        props,                                              // <4>
        request,
        {
            id: "react4xpApp",
            body: `
                <html>
                    <head></head>
                    <body class="xp-page">
                        <div id="react4xpApp"></div>
                    </body>
                </html>
            `
        }                                                   // <5>
    )
};

----

<1> Fetching the content data defined in the XML (and in the next line, we're unpacking it into `pageConfig` while choosing that missing data should just display emptiness, not throw an error).
<2> The `props` object is just any standard JS object. So the data can of course come from anywhere you want and take any shape - with one exception: `props` needs to be *serializable*, so functions can't be passed here!
<3> Connecting the field names in `pageConfig` from _hello-react.xml_ to the prop names that _hello-react.jsx_ needs.
<4> See how this makes the first two arguments of `React4xp.render` analogous to XP's `thymeleaf.render` template engine? The first argument, `entry`, is just a reference to what should be rendered (_react component_ ~ _template_), and the second one is a collection of data injected into it (_props_ ~ _model_).
<5> To keep things simpler and clearer, just remove the `clientRender` flag from the previous example.

There it is, now let's take a look!

=== Setup and rendering

Compile the project, enter Content Studio Repeat (the first two steps in link:#first_setup_render[the previous setup]), and edit the content you created (double-click it to open a new tab).

You should still see it in the preview panel on the right (although, since you probably created the content without any data created along with it, it might not display much of the text. We'll fix that):

[.thumb]
image:hello_cs.png[link="media/hello_cs.png"title="Editing Hello World, same as before. Click to see a high-res version", width=1024px]

{zwsp} +

Now, when you click the preview panel, the page-config editing panel should open on the right, with the data fields containing the default text we defined. Once you click Apply/save, the preview panel to the left should update.

[.thumb]
image:hello_editorial.png[link="media/hello_editorial.png",title="Editing Hello World in the page-config panel in Content Studio. Click to see a high-res version!", width=1024px]

{zwsp} +

So now, it looks the same as before, but with editorial data instead of hardcoded text. Boring, and too similar to the previous example; just repeating "Hello World" might cause a little confusion. *Try adding your own data in the fields*, for example changing _"world"_ into _"link:https://montypython.fandom.com/wiki/Bruces_sketch[Bruce]"_ etc, to keep it clear.

*Apply/save* your new props, and the output should change again. But since we're still in Content Studio, it's justa static serverside-rendered update. To see the final rendering with your new data, all active, click _Preview_ on the top to open the page in a fresh tab:

[.thumb]
image:gday_bruce.png[title="Rendering: G'day Bruce. This is turning into one big philosophers' joke, isn't it?", width=768px]


=== Output

So did anything change in the rendered response, compared to link:#hello_output[the first serverside-rendered example]? Not all that much, actually. Depending on what data you inserted and the resulting `props`, your page source should look something like this:

[source,html,options="nowrap"]
----
<html>
<head></head>
<body class="xp-page">

    <!--1-->
    <div id="react4xpApp">
        <div data-reactroot="">
            <h1>G'day<!-- --> <!-- -->Bruce<!-- --> !</h1>
            <p>Click me: <span id="counter">42</span> <!-- -->tubes<!-- --> on the wall.</p>
        </div>
    </div>

    <!--2-->
    <script src="/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/react4xp/externals.489d97cdf.js"></script>
    <script src="/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/react4xp-client/"></script>
    <script src="/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/react4xp/site/pages/hello-react/hello-react.js"></script>

    <script defer>
        React4xp.CLIENT.hydrate(
            React4xp['site/pages/hello-react/hello-react'],
            "react4xpApp",
            {                           <!--3-->
                "message": "G'day",
                "messageTarget": "Bruce",
                "droppableThing": "tubes",
                "initialCount": 42,
                "react4xpId": "react4xpApp"
            },
            1, 0
        );
    </script>
</body>
</html>

----
<1> Since we removed the `clientRender` flag again, the target container `react4xpApp` comes filled from the server. But now with a rendering with _your_ texts from `props` already inserted.
<2> There's still no change in the asset URLs, but since we changed _hello-react.jsx_, the content of _hello-react.js_ has of course been recompiled.
<4> The `props` are used in the clientside `.hydrate` call. For convenience, the `id` is automatically added as the `react4xpId` prop. Handy for use cases where a react component needs to uniquely identify itself.


{zwsp} +
{zwsp} +

[[_react4xp_render]]
== React4xp.render

Now might be a good time to take a closer look at the `.render` call from the ES6 controller in link:#controller_with_props[the example above]:

====
React4xp's `.render` is a one-in-all shorthand function for a lot of use cases. Basically, take any HTML string and pass it through `.render` as a `body` option, and react4xp will insert the react component into the HTML string and add any necessary page contributions to make it all work.

*Signature*, analogous to thymeleaf's familiar `render(view, model`) signature - but with some extra parameters and a full XP response object returned:

`{body, pageContributions} = React4xp.render(entry, props, request, options);`

*Parameters:*

- `entry` (mandatory, string or component object): this is the reference to the "template", the react component to be rendered. If it's a JSX file with the same name in the same folder as an XP component, simply use the `portal.getComponent()` object here. In this example,  it's the _hello-react_ page, but you can do the same thing from part or layout controllers too. We'll come back to a more specific way to reference files anywhere in your project, under link:#jsxPath[jsx path]. By the way, a react component that is used by react4xp this way is called link:#entries[an entry].
- `props` (optional object, must be serializable): data model passed into the react component.
- `request` (link:https://developer.enonic.com/docs/xp/stable/framework/http[XP request object], kind of optional, but _mandatory for react activation_): This is to keep the component rendered static and serverside-render if the rendering happens inside XP content studio. No browser react activation (or client-side rendering) happens inside content studio, you only get a visualization from the initial `props`. Special case: if `request` is omitted/falsy, page-contributions rendering is completely skipped. Note: the .render `options` argument is still valid: the rendered static HTML is still inserted into the HTML from the added `body`, and `pageContributions` are still added.
- `options` (optional object): additional options to control the rendering:

** `id` (string): ID of the component, matching the ID of an element in `body`. React will render into that container element, replacing whatever was already there. If missing, a random ID is generated.
** `body` (string): HTML string, a base for the returned `body`. Can be a hardcoded string, or come from a thymeleaf/mustache/XSLT render, and so on. Just make sure the `id` option matches an HTML id here (what happens if not? React4xp creates a target element with that ID, last in the root element of `body`). If there's no `body` option, a matching-ID `<div>` target container is generated.

** `pageContributions` (object): you might already have some page contributions you want to return together with the ones generated by react4xp. Same way as with `body`, just add them here to pass them through `render`. Order: the ones you add here are output before the ones rendered.
** `clientRender` (boolean): if `true` (truthy, actually), the server-side rendering is skipped (in live mode and previews. Inside content studio's browser or edit modes, you still only get a static server-side rendered representation).

*Returns* an link:https://developer.enonic.com/docs/xp/stable/framework/http[XP response object] with these main attributes:

- `body`: rendered HTML string. When server-side rendered, the whole HTML is inserted into the matching-id element inside the `body` option (if the `body` option is added. If not, a surrounding `<div>` is used). When client-side rendered, no HTML is inserted into `body` (or the generated container) - that's left to the client.
- `pageContributions`: a regular link:https://developer.enonic.com/docs/xp/stable/cms/contributions[XP page contributions] object. Includes everything the browser needs to activate (or client-side render) the react component: auto-compiled assets for the entry (_hello-react.js_ in this example) and whatever it may depend on (most importantly, react and react-dom in an _externals_ asset), and a client-side react4xp wrapper asset. These are all optimized and served to the client by react4xp services.
====

`.render` is just one way. React4xp has other, more detailed and flexible ways of rendering, we'll link:#custom_flow[look at those] in a bit.



{zwsp} +
{zwsp} +

[[xp_pages_parts]]
== 3: XP Pages, Parts and Regions

So far, we've only used an XP Page and just rendered a react component directly from the controller there. It's fine, but not really making good use of XP's excellent CMS and WYSIWYG powers. So let's move into that territory.

React4xp can also render from XP _Part or Layout controllers_, creating react-rendered XP elements that can be dragged into any regular XP Region. And besides, react4xp can (serverside) render these XP Regions themselves, which can then accept any XP Parts/Layouts dropped into them (as well as Fragments, Text and Image components, of course).

In this example, we'll do both:

* Make a react-rendered general link:https://developer.enonic.com/docs/xp/stable/cms/components[XP Page Controller] with a working XP Region.
* Make a react-rendered link:https://developer.enonic.com/docs/xp/stable/cms/components#part[XP Part] that can be dragged into the Region.

.Files involved:
[source,files]
----
site/pages/
  default/
    default.xml
    default.es6
    default.jsx

site/parts/
  color/
    color.xml
    color.es6
    color.jsx
----



=== Code

==== XP Page controller

We'll make a bare-bone Page controller first: _site/pages/default/_ .

TIP: If you make a new Page controller or modify _site/pages/hello-react/_ from the first examples, is up to you - we won't be using _hello-react_ anymore. If you modify and rename the previous files, just remember to rename the _hello-react_ *folder and file names* identically.


*The page definition* is again very simple. We're now leaving the `<form>` node empty, but adding a `<regions>` node with a single `"main"` Region defined in it:

.default.xml:
[source,xml,linenums,options="nowrap"]
----
<page>
    <display-name>Default page</display-name>
    <description>React4xp-rendered Page controller</description>
    <form/>
    <regions>
        <region name="main"/>
    </regions>
</page>
----


*The react component* has a single focus: rendering a Region:

.default.jsx
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';
import Regions from 'react4xp-regions/Regions';    // <1>

export default (props) => (
    <div className="default-page">
        <Regions {...props} />                     // <2>
    </div>
);
----

<1> Importing a Region template from an NPM package that comes with react4xp (link:https://www.npmjs.com/package/react4xp-regions[react4xp-regions]).
<2> Nesting the Region in our component. Using mainly `props.regionsData` and selecting all regions named in `props.names`, it will render _all_ Regions given by `props`.

The `props` of course come from the *Page controller*. Still similar to the previous two examples, but we're adding props that are needed by `<Region>` in the react component.

.default.es6:
[source,javascript,linenums,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const content = portal.getContent();
    const entry = portal.getComponent();

    const id = `react4xp_${content._id}`;   // <1>

    const props = {
        regionsData: content.page.regions,  // <2>
        names: "main",                      // <3>
        tag: "main",                        // <4>
    };

    return React4xp.render(
        entry,
        props,
        null,                               // <5>
        {
            id,
            body: `
                <html>
                    <head>
                        <title>${content.displayName}</title>
                    </head>
                    <body class="xp-page">
                        <div id="${id}"></div>
                    </body>
                </html>
            `
        }
    );
};
----

<1> The XP content ID is nice and unique, let's just use that to bind the react component to the target element.
<2> Here, `content.page.regions` are content data containing the Region we defined in _default.xml_ as well as data about content dropped into it. This is mapped to the `regionsData` prop.
<3> The `names` prop can be a string or a string array. It's used to select which Regions (by Region name defined in _default.xml_) to render, in case there are more Regions in `content.page.regions`. Rendering will occur in the order of the string array. If the `names` prop is missing, all the regions defined in _default.jsx_ are rendered, but the order is less predictable.
<4> The `tag` prop optionally sets which HTML tag will be at the root of the section rendered by `<Regions>`, instead of `<div>`. Here, we're going for `<main>`.
<5> We're setting the `request` argument of `React4xp.render` to _null_ - switching off the auto-handling of how _this_ particular rendering is done inside/outside Content Studio, and just forcing `React4xp.render` to *always output a static, serverside rendered HTML body without page contributions*. But why? Two reasons:
  - The way it is now, _default.jsx_ and the Regions in it has no need for page contributions. Only the static HTML is of interest; no client-side JS code needs to be activated/rendered in the client, and there's no styling or anything else coming from it. So by skipping the page contributions rendering, performance is improved a little.
  - There is a *caveat when using react4xp to render Regions* (like in default.jsx): currently, page contributions don't work for XP Parts (and Layouts) that are dropped into a react4xp _clientside_-rendered Region. So Regions must be serverside rendered if they are meant to contain XP components that need their own page contributions to work (for example react4xp parts, which rely on page contributions to be activated in the client). This way, by forcing a serverside Regions rendering, we prevent that corner case from failing and make sure _any_ XP element dropped inside the Region will work, even clientside-rendered react4xp parts.

==== XP Part

*The part definition* is still pretty unremarkable, but now there's a `greetee` TextLine input field, ready to add some editorial text from Content Studio.

.good-day.xml:
[source,xml,linenums,options="nowrap"]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<part>
    <display-name>Good day React</display-name>
    <description>Greeting with two props, one of them editorial</description>
    <form>
        <input type="TextLine" name="greetee">
            <label>Who shall we greet?</label>
            <occurrences minimum="1" maximum="1"/>
            <default>Earth</default>
        </input>
    </form>
</part>
----

*The react entry* is even more minimal this time:

.different-example.jsx
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) => <p className="different-greeting">{props.message} {props.messageReceiver}!</p>;
----

But note that instead of using the name of the part itself (_"good-day.jsx"_), the entry is called "_different-example.jsx_". Also, we're using two react props `message` and `messageReceiver` (and a classname, just to mark the `p` element in the output HTML).

Moving on to the rendering call in *the part controller*:

.good-day.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {

    const component = portal.getComponent();

    const props = {                                     // <1>
        message: "G'day",
        messageReceiver: component.config.greetee
    };

    return React4xp.render(
        "site/parts/hello-react/different-greeting",    // <2>
        props,
        request,
        { clientRender: true }                          // <3>
    );

};
----

Some things to note, especially compared with the previous example:

<1> Here we're adding the top-level *props*: info passed into the react component as it's created. This of course corresponds to the props we're using in the react entry _different-example.jsx_ above. If you're used to the _model_ concept from the thymeleaf/mustache templates in XP, `props` is pretty much the same. The first prop, `message`, is just hardcoded. But it could be a string from anywhere in the controller: the second prop, `messageReceiver` is fetched from the XP part's own config data - the `greetee` field we defined in the part descriptor _good-day.xml_ above.
<2> In the previous example, we added `component` here, to refer to the jsx file with the same name in the same folder. We could do that here too, if we wanted to point to a react entry called `site/parts/good-day/good-day.jsx`. But we'll use a custom string instead, to refer to a specific JSX entry: _different-greeting.jsx_ in the folder _site/parts/good-day/_. This string is the *jsxPath* of the entry _different-greeting.jsx_: jsxPaths is the way to refer to a react entry anywhere in your project - we'll look closer at link:#entries[entries] and link:#jsxPath[jsxPath] in a moment. For now, just note that we're using the entire path down to _site/_, and skipping the ".jsx" file extension.
<3> In the `options` parameter, we're only adding a `clientRender: true` flag. This makes the renderer skip serverside-HTML-rendering and _only_ generate the page contributions needed for clientside-rendering (in XP live view and preview windows _outside content studio_, that is. Inside content studio, you'll only see an inactive serverside rendering anyway).

[TIP]
====
Remember how in the previous example, _hello-react.es6_, we added the parameters `id` and `body` to the _.render_ options? We could use them here too, but they aren't needed. The `body` option is only a surrounding HTML string that the rendered react will be inserted into - but in this case we're making a standalone XP Part which XP will insert into a Page anyway. So no extra `body` is needed (although _.render_ will generate a container element anyway, a placeholder for the react rendering process to work). As for the `id` option: since that's missing, the react component will just get a generated random ID (automatically shared with the generated container element).
====


*Okay, enough - time to run the example!*

[[_setup_and_render]]
=== Setup and render

Let's add it to a page in Content Studio and render it:

1. Run `enonic project deploy` from your shell, start the sandbox and point your browser to `localhost:8080/admin`.
2. Log in to XP and open Content Studio.
3. Create some content, anything with a Region will do (so not the _hello-react_ page from the first example, but maybe a Site with the Default page controller from the starter, or a https://market.enonic.com/vendors/enonic/landingpage-lib[a landing page]).
4. Insert the new Part into the Region, and select the XP Part you just made, _Good day React_:

[.thumb]
image:gday_earth.png[title="Content studio preview: G'day Earth.", width=768px]


[start=5]
5. Of course, having both "Hello World" and "G'day Earth" in the same project might cause a little confusion. Better enter *"Bruce"*  into the _"Who shall we greet"_ textfield, to keep it clear. Apply/save to see the props change immediately; serverside-rendered since we're in content studio.
6. Enter the preview to view the content outside of Content Studio. You should now see, _clientside_-rendered:

[.thumb]
image:gday_bruce.png[title="Final rendering with an editorially changed prop: G'day Bruce.", width=768px]


=== Output

If we dig into *the output page source* of the preview tab, the HTML is similar to what we got from the previous example. Depending on your content and local setup, it'll look something like this:

[source,html,options="nowrap"]
----
...
<body class="xp-page">
    <div id="react4xp_da5aa513-55aa-4787-a208-14cb8921b572">
        <div class="default-page" data-reactroot="">
            <div data-portal-region="main" class="xp-region">
                <div data-portal-component-type="part" id="_23744858"></div> <!--1-->
            </div>
        </div>
    </div>
    <script src="(...your.app.service) /react4xp/externals.489d97cdf.js"></script>
    <script src="(...your.app.service) /react4xp-client/"></script>
    <script src="(...your.app.service) /react4xp/site/parts/good-day/different-greeting.js"> <!--2-->
    </script>
    <script defer>
        React4xp.CLIENT.render(                                   // <3>
            React4xp['site/parts/good-day/different-greeting'],   // <4>
            "_23744858",                                          // <5>
            {
                "message": "G'day",
                "messageReceiver": "Bruce",
                "react4xpId": "_23744858"
            }
        );
    </script>
</body>
...
----

Most notable differences from the first example:

<1> The target container now has a random ID (since we didn't add an `id` option in the controller). And it's initially empty; because of the `clientRender:true` flag, there was no rendered HTML from the server.
<2> Since we selected a named entry with the jsxPath, the full path to the _compiled_ entry asset is inserted.
<3> Again because of the `clientRender:true` flag, the browser is calling `.render` instead of `.hydrate`. `React4xp.CLIENT.render` has link:https://www.npmjs.com/package/react4xp-runtime-client#render[the same signature] as `React4xp.CLIENT.hydrate`: `(entry, targetElementId, props)`.
<4> So the client wrapper renders our react entry...
<5> ...and inserts it into the empty target container, the one matching the (generated) unique ID.

[TIP]
====
We only added the `message` and `messageReceiver` props in the controller. The last prop, `react4xpId`, is the unique ID of the component, same as the target container element ID. It's always added as a prop for each entry, conveniently helping if you need to separate multiple instances of the same component (e.g. allowing them to share a common redux store without meddling with each other's state).
====

{zwsp} +
{zwsp} +

[[free_structure]]
== 4: Free source file structure

{zwsp} +
{zwsp} +

[[entries_and_jsxpath]]
== Entries and jsxPath

We've mentioned React4xp _entries_ and their _jsxPath_ earlier. Here are the details about what they are (feel free to just skim through this, move on with the next examples, and use this for reference later):

[[entries]]
====

*ENTRIES*

React4xp is structured around _entries_. An entry is just *a React component that can be accessed by react4XP*. They are the _only_ react files that react4xp can use directly.

An entry is pretty much just a *standard JSX file*, that follows two requirements (link:media/entries_howto.png[cheatsheet]):

1. *default-exports a function*, this function _may_ take a `props` argument (serializable JS object) and _must_ return a react component (pure functional component or old-school React Component), and
2. is located either in a folder either below *_/site/_* or below one of the *entryDirs* folders listed in _react4xp.properties_ (see also jsxPath below).


.A mental model (image links to another cheatsheet):
image:entries.png[link="media/entries_cheatsheet.png",title="React4xp Entries basic structure. Controllers can use entries, entries can import anything", width=600px]

Think of *entries as "bridge elements"*. On the XP/server side, you have the controllers with their backend XP flow, logic and XP lib imports. Entries are the beginning of the frontend side (although the same code is also used for serverside-rendering): they do regular frontend-style ES6 logic and can *import* stuff from NPM/node_modules, your own logic, nested react components, whatever - even other entries.

React4xp handles them in build-time and runtime: locates entries, compiles them into *entry assets* (under _/build/resources/main/assets/react4xp_), and serves them to the client.

Entries become separate *root level react apps*. Good to know if you display more than one entry on a page - which you can, but you might also consider using just one entry for the root, and multiple imports in it.

For example, earlier in this tutorial we've seen the entries _hello-react.jsx_ and _different-greeting.jsx_, they are compiled into the assets _hello-react.js_ and _different-greeting.js_.
====

[[jsxPath]]
====
*JSX PATH*

Each entry is identified by its own _jsxPath_.

Short and brutal: the jsxPath is a name string generated from the path and filename of the compiled asset after building, relative to _/build/resources/main/assets/react4xp/_ - without file extension.

During development though, these *3 rules* are probably easier:

1. If you use the `component` object like in link:#hello_react_page[the first example], you can ignore the jsxPath. `React4xp.render` will use the component object to find an entry with the same folder/same name as a part/page/layout controller.

But if you need to access an entry from a different folder - from anywhere actually - here's *how to find the jsxPath of an entry*:

[start=2]
2. If an entry's source file is a JSX under _/src/main/resources/_ *_site/_*, the jsxPath is the source file's path relative to _/src/main/resources/_ - unix-style and without file extension.
* So the jsxPath will start with `site/...` etc (and the asset will be compiled into a folder below _/build/resources/main/assets/react4xp/_ *_site/_*, and so on).
3. Or, using the setup from the starter, you can also put your entries under _src/main/resources/_ *_react4xp/entries_*. Then the jsxPath (and compiled-asset path) will be relative to _/entries/_ instead.
* Actually, you can control this with the `entryDirs` property in _react4xp.properties_. The starter has added `entryDirs=entries` here, but this is a comma-separated list of folder names relative to _src/main/resources/react4xp/_. Remember, if you add more entryDirs or replace `entries`, the jsxPaths will always be relative to those new entryDirs.

* *For example:* add `../myComponents` to entryDirs: `entryDirs=entries,../myComponents`. Since entryDirs and the "../" are relative to _src/main/resources/react4xp/_, the new entry source folder is _src/main/resources/myComponents/_. Now new JSX files can be put there, and get a jsxPath relative to that. So the entry _src/main/resources/myComponents/_ *_app/myEntry.jsx_* will get the jsxPath `"app/myEntry"`, and will be compiled to the entry asset _/build/resources/main/assets/react4xp/app/myEntry.js_.

If you're ever unsure: after building, all the *jsxPaths of all the available entries* are stored in _build/resources/main/assets/react4xp/entries.json_. This file is generated by webpack during build. It's also used by the runtime, so it shouldn't be deleted or edited!

NOTE: jsxPaths are not actually file system paths, but *static name strings*. So avoid shortcuts and relative references like `../`, etc.
====




Okay, time to move on to the next example and lesson!

{zwsp} +
{zwsp} +

[[custom_flow]]
== 5: Custom flow

* Use the *jsxPath* to refer to a specific *entry* (and get to know what they are)


In this example we won't use `.render`.
Instead, we'll look at a more explicit syntax that gives you better control and opportunities for logic steps when you handle your entry.

We'll construct *a data-holding React4xp object* from an entry, manipulate it a little,
and use its built-in _separate_ methods for rendering the `body` and `pageContributions` for the controller response.

Other options demonstrated here: we will...

* use a thymeleaf template. It will have a target container for the react rendering, with an ID that comes from the data-holding object and is inserted by thymeleaf. When this template HTML string is rendered, we're _passing it through_ the `.renderBody` step.
* make some raw XP page contributions too, before rendering. They will contain a script with inserted editorial data. Then that `pageContributions` object is _passed through_ `.renderPageContributions`, adding it to the React4XP page contributions
* use a link:#jsxPath[jsxPath] to point to an entry outside of XP's _/site/_ structure.

.Files involved:
[source,files]
----
react4xp/entries/
  ColorThing.jsx
site/parts/custom-flow/
  custom-flow.xml
  custom-flow.html
  custom-flow.es6
----




=== Code

*The part definition* again defines some editorial data: `color`.

.custom-flow.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>CustomFlow example</display-name>
  <description>AKA. The color thing</description>
  <form>
    <input name="color" type="TextLine">
      <label>What's the color of the thing?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>red</default>
    </input>
  </form>
</part>
----


*The react entry* uses that `color` from `props`, both as text and inline style:

.ColorThing.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) =>
  <div style={{border: `1px dotted ${props.color}`,margin:"5px",padding:"5px" }}>
    <h2>The {props.color} thing</h2>
    <p style={{color: props.color}}>Hey, I'm pretty {props.color}!</p>
  </div>;
----

*The Thymeleaf view* receives the ID of the target container element from Thymeleaf:


.custom-flow.html
[source,html,linenums,options="nowrap"]
----
<div>
    <p>Here comes the thing:</p>
    <div data-th-id="${targetId}"></div>
</div>
----


Finally, *the controller*:

.custom-flow.es6
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

const view = resolve('custom-flow.html');

exports.get = function(request) {
    const component = portal.getComponent();

    const reactObj = new React4xp('ColorThing');            // <1>

    reactObj
        .setProps({ color: component.config.color })
        .uniqueId();                                        // <2>

    const model = {
        targetId: reactObj.react4xpId                       // <3>
    };
    const preRenderedBody = thymeleaf.render(view, model);

    const preExistingPageContributions = {
        bodyEnd: `<script>
        	console.log('Okay, rendered the ${reactObj.props.color} thing.');
        		</script>`
    };                                                      // <3>

    return {                                                // <4>

        body: reactObj.renderBody({
            body: preRenderedBody,                          // <5>
        }),

        pageContributions: (
            request.mode === 'live' ||                      // <6>
            request.mode === 'preview'
        ) ?
            reactObj.renderPageContributions({              // <7>
                pageContributions: preExistingPageContributions
            }) :
            undefined
    }
};
----


<1> Constructing the data-holding React4XP object `reactObj`. The constructor takes *one mandatory argument*: an link:#entries[entry reference]. Just like the first argument in `.render`, the entry reference can be a link:#jsxPath[jsxPath] OR an XP component object. Here it's a jsxPath. So why is `ColorThing`, and _only_ that, the jsxPath to _ColorThing.jsx_? Because the JSX file is at the root level of the React4XP entries base folder: _src/main/resources/react4xp/entries_.
<2> The React4XP object has setter methods that return the object itself, so you can set any optional attributes with a chained builder pattern like here. The uniqueId() method generates a unique ID of the object (and the target container element that uses `model.targetId`). If an object doesn't have an ID, this will be called by default when rendering (so we could have just skipped it here). The order of the setter methods doesn't matter. This example is equivalent to:
	`reactObj.setProps({color: component.config.color});`
	`reactObj.uniqueId();`
<3> We can read attributes from `reactObj` before the rendering. At this point, the ID (`react4xpId`) and `props` are set in it. We read them out and inject them into the thymeleaf model and some random page contributions.
<4> Here, `body` and `pageContributions` are rendered separately: `.renderBody` and `.renderPageContributions`. Remember that this is different from `.render` which does everything in one go.
<5> The Thymeleaf-rendered `preRenderedBody` is passed through `.renderBody` in a `body` parameter. This insert the rendered react into the `preRenderedBody`. Again, the `body` parameter is optional - if we don't submit it, `.renderBody` will just generate a target container with a matching ID.
<6> The other difference from `.render`: _there's no automatic selection of rendering mode here_. If we want to *avoid active client-side JS running in Content Studio's _edit_ and _inline_ modes*, we now need to do it manually: detect the viewing mode from the `request` object and just skip the pageContributions.
<7> `.renderPageContributions` renders the necessary page contributions for activating the entry in the client. Same way as how we passed `body` through `.renderBody`, we pass `preExistingPageContributions` through `.renderPageContributions` (as the optional `pageContributions` parameter) to _add_ them to the rendered pageContributions.

[NOTE]
====
Just like the `.render` method in example 2, we can control `.renderBody` and `.renderPageContributions` with the `clientRender` parameter. In this example, we called them both without it (so `body` is rendered on the server-side into the HTML, and `.hydrate` is called on the body in the client, instead of `.render`).

Make sure the `clientRender` parameter *matches between the two rendering functions*. If we add it to `.renderBody` (and it's true/truthy), it should be in `.renderPageContributions` too.
====

*Okay, let's take a look!*


=== Setup

Like in link:#_setup_and_render[the setup in example 2], open Enonic XP Content Studio, add the new part to some content, select and edit it and change the Color of the Thing to some HTML compliant color string, for example "blue".

Save, and it should look something like this:

[.thumb]
image:the-blue-thing2.png[title="Rendered text in Content Studio is blue, and says: the blue thing" width=1068px]


=== Output

If we open it in Preview and look at the browser console, we also see that the little `console.log` script from the controller has picked up the same `color` prop from the React4XP object:

[.thumb]
image:the-blue-thing.png[title="Rendered preview looks the same as in Content Studio, but now we also see that the expected output was printed in the browser console." width=1068px]


*The output page source* should be similar to this:

[source,html,options="nowrap"]
----
<body>
    <main data-portal-region="main" class="xp-region">

        <div data-portal-component-type="part">
            <p>Here comes the thing:</p>
            <div></div>
            <div id="_99689402">
                <div style="border:1px dotted blue;margin:5px;padding:5px" data-reactroot="">
                    <h2>The <!-- -->blue<!-- --> thing</h2>
                    <p style="color:blue">Hey, I'm pretty <!-- -->blue<!-- --> !</p>
                </div>
            </div>
        </div>

    </main>
    <script src="(...) react4xp/externals.88e80cab5.js"></script>
    <script src="(...) react4xp-client/"></script>

    <script>console.log('Okay, rendered the blue thing.');</script>

    <script src="(...) react4xp/ColorThing.js"></script>
    <script defer>React4xp.CLIENT.hydrate(React4xp['ColorThing'], "_99689402", {
        "color": "blue",
        "react4xpId": "_99689402"
    });</script>
</body>
----

NOTE: the random but matching ID (_uniqueId_) of the target container and in the `React4xp.CLIENT.hydrate` call.


{zwsp} +
{zwsp} +

[[imports_chunks]]
== 6: Imports and dependency chunks

Finally, a slightly more life-like example. Looking at these features:

- We'll stay with the syntax from the previous example. That lets us make a part with *multiple entries* - both different entries and re-using multiple instances of the same entry. In the previous example we saw how to pass `body` and `pageContributions` through a rendering step. Here, we'll use that for *chaining*: builing them gradually by passing them through the rendering steps of all the entries.
- *Importing stuff* into entries - third-party JS libs etc, nested react components, etc, or nesting an entry in another.
- *Dependency chunks*: using only source folder structure, we can easily get webpack to compile and pack code into controlled bundles, e.g. code that's frequently used together in the client, served in an optimized way by XP.

.Files involved:
[source,files]
----
react4xp/
  entries/
    mySubfolder/                <!--1-->
      BuilderClickerEntry.jsx
  myChunk/                      <!--1-->
    BuilderClicker.jsx
site/parts:
  /chaining/
    chaining.jsx
    chaining.xml
    chaining.html
    chaining.es6
----

<1> Just make a mental note of the two added subfolders.

=== Code

The first entry:

.react4xp/entries/mySubfolder/BuilderClickerEntry.jsx:
[source,JavaScript]
----
import React from 'react';

import BuilderClicker from '../../myChunk/BuilderClicker';

export default (props) => <div className="builderclicker-entry">
		<BuilderClicker {...props} />
	</div>;
----

Some repetition from before: remember how *JSX files below `react4xp/entries` will be compiled to entries, with a jsxPath relative to that folder and without the file extension*? So this will be an entry with the jsxPath `mySubfolder/BuilderClickerEntry`.

It's functionally pretty slim, it doesn't do much except import another React component, `react4xp/myChunk/BuilderClicker` and pass the props down to it. Since `BuilderClicker` is not under `react4xp/entries`, it's not an entry and can't be used by React4XP. Which is why it needs an entry like this.


*A slightly heavier, non-entry React component:*

.react4xp/myChunk/BuilderClicker.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

class BuilderClicker extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            first: props.first,
            second: props.second,
        }
    };

    // Doubles the 'first' or 'second' string in state, depending on the key.
    makeMore = (key) => {
        this.setState({[key]: this.state[key] + " " + this.state[key]});
    };

    render() {
        return <div className="builderclicker">
            <h3 style={{color:"green"}}>
                <span onClick={() => this.makeMore('first')}
                      style={{cursor: "pointer"}}
                      className="first">{this.state.first}
                </span> <span onClick={() => this.makeMore('second')}
                      style={{cursor: "pointer"}}
                      className="second">{this.state.second}</span>
            </h3>
        </div>;
    }
};

export default (props) => <BuilderClicker {...props} />;
----


`BuilderClicker` displays two texts in one line, and builds more by doubling each of the texts whenever they are clicked in the browser.

This is a _non-entry_ React component, that will be imported by several of the entries in this example (`BuilderClickerEntry` is one of them). Because of its source file location, `BuilderClicker` will be compiled into a highly reuseable, optimized and auto-handled chunk called `myChunk`:

==== Chunks:


*JSX files that are _not_ under `site/` or `react4xp/_entries` won't be compiled into entries*. They don't have a jsxPath, and *need to be imported by an entry* to be used in React4XP (or to be precise: they must be part of an import tree with an entry on top).

*Everything that's imported from files in other subfolders below `react4xp/` will be compiled into chunks*. These are "sub-library" code bundles with the same name as the subfolder. They are *optimized* for repeated loading and runtime import, and cached for reuse, with a cache-busting content hash added to the file name.

Chunks are made to be *fire-and-forget:* you don't need to handle them in any way after naming the subfolders and importing the contents correctly. React4xp takes care of them during serving, caching and server-side rendering.

One recommended usage - an entry as a bridge between React4xp and more heavyweight React components:

[TIP]
====
*Since the chunks are most optimized, it's recommended to keep the entries slim and put as much of the heavy and reusable stuff as possible into chunks.* Also, it's best to keep the non-entries in chunks: each JSX entry is compiled to its own separate JS file. If an entry imports a non-entry piece of code that's _not in a chunk either_, it will just be compiled into the entry's JS "bundle", making it more heavy-weight.
====


*Another entry in the part:*

.site/parts/chaining/chaining.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';
import BuilderClickerEntry from '../../../react4xp/_entries/mySubfolder/BuilderClickerEntry';

export default (props) => <BuilderClickerEntry {...props} />;
----

Three things to note here:

* An entry can import and nest another entry just fine (if you should ever need to),
* The same React component, `BuilderClicker`, is imported from its chunk more than once in the same part (but only loaded once in the client),
* The two instances of it are functional and independent in the client. The fact that it's imported into the part through two different entries doesn't matter for this - we'll show this by using _this_ entry twice in the controller.


*The part definition* doesn't define anything editorial this time:

.site/parts/chaining/chaining.xml:
[source,xml]
----
<part>
  <display-name>Chaining</display-name>
  <description>Multiple react components, chaining, nesting, hydration</description>
  <form />
</part>
----


*The part view* has two target containers (with hardcoded IDs) and a horizontal divider, and clearly expects some more containers to be added:

.site/parts/chaining/chaining.html:
[source,html,linenums,options="nowrap"]
----
<div class="chaining-example">
    <h1>04 - Chaining Example</h1>
    <p>These two target containers existed in the HTML:</p>
    <div id="a-target-container"></div>
    <div id="another-target-container"></div>

    <hr style="display:block; margin:20px; width:100%; height:1px; border:1px dotted #aaa;"/>
    <p>The rest of the containers don't exist before rendering, but are inserted at the end:</p>
</div>
----


And finally, the juicy part controller:


.site/parts/chaining/chaining.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const thymeleaf = require('/lib/thymeleaf');
const React4xp = require('/lib/enonic/react4xp');

const view = resolve("chaining.html");

exports.get = function(request) {
    const component = portal.getComponent();

    const clientRender = (request.mode !== 'edit' && request.mode !== 'inline'); <!--1-->


    const firstReact4xpObj = new React4xp('mySubfolder/BuilderClickerEntry') <!--2-->
        .setId("a-target-container")
        .setProps({
            first: "Click",
            second: "ME!"
        });

    const secondReact4xpObj = new React4xp(component) <!--3-->
        .setId("another-target-container")
        .setProps({
            first: "No click ME!",
            second: "I do the exact same thing only better!"
        });

    // ------------------------------ A horizontal separator comes here in the view:
    // a new section where React4XP generates and inserts target containers where the
    // IDs didn't exist in the HTML


    const thirdReact4xpObj = new React4xp(component) <!--4-->
        .setId("a-third-container-doesnt-exist-but-will-be-generated") <!--5-->
        .setProps({
            first: "Here I am.",
            second: "Again."
        });


    let body = thymeleaf.render(view, {});

    body = firstReact4xpObj.renderBody({ body }); <!--6-->
    body = secondReact4xpObj.renderBody({ body, clientRender });
    body = thirdReact4xpObj.renderBody({ body });

    let pageContributions = firstReact4xpObj.renderPageContributions();
    pageContributions = secondReact4xpObj.renderPageContributions({
    	pageContributions,
    	clientRender
    });
    pageContributions = thirdReact4xpObj.renderPageContributions({ pageContributions });


    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {	<!--7-->
        const notUniqueComp = new React4xp(
            	'site/parts/hello-react/hello-react'
            )
            .setId('this-is-not-unique')
            .setProps({ greetee: `${cardinalNum} repeated thing`});

        body = notUniqueComp.renderBody({ body });
        pageContributions = notUniqueComp.renderPageContributions({ pageContributions });
    });


    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {
        const uniqueComp = new React4xp(
            	'site/parts/hello-react/hello-react'
            )
            .setId('this-id-is-unique').uniqueId() <!--8-->
            .setProps({ greetee: `${cardinalNum} unique thing`});

        body = uniqueComp.renderBody({body});
        pageContributions = uniqueComp.renderPageContributions({ pageContributions });
    });


    return { <!--9-->
        body,
        pageContributions: clientRender ?
            pageContributions :
            undefined,
    };
};

----


<1> *Content Studion and client-side rendering/hydration:* Just like we did in the previous example, it's a good idea to respond to XP's viewing mode: are the react components being displayed inside Content Studio (request.mode is 'edit' or 'inline')? If so, the client-side JS of Content  Studio may clash with react's JS. We're making a boolean `clientRender` for common control of all the entries in this part. This allows client-side rendering and hydration only outside Content Studio, and makes React4xp render static and un-hydrated HTML visualizations inside Content Studio - giving a visualization everywhere but activation only outside of Content Studio. Repetition: the `React4xp.render` shorthand function does all this automatically, if you prefer that.
<2> Importing `BuilderClicker` from `myChunk` a first time, through `BuilderClickerEntry`...
<3> ...and a sceond time, through the part's own entry (referred by `component`) which nests `BuilderClickerEntry`...
<4> ...and a third time, through the same part's own entry again.
<5> From here on down, none of the IDs will exist as target element IDs in the body. React4XP auto-handles this by inserting them at the end of `body`, in the order of chaining:
<6> *Chaining:* First creates a `body` starting point from the local Thymeleaf template. This is _passed through_ the `.renderBody` method of all the React4XP objects, each one expanding `body` by inserting either just a container element (`clientRender`) or rendering more React into it. `firstReact4xpObj` and `thirdReact4xpObj` will be server-side-rendered, `secondReact4xpObj` will be client-side-rendered. Note how *the `clientRender` parameter matches for each React4XP object*, between the `renderBody` and `.renderPageContributions` calls in the next step. `.renderPageContributions` works the same way: a `pageContributions` object is expanded with activating scripts for each time it passes through a React4XP object. `.renderPageContributions` only appends what's necessary, so that shared components and chunks etc aren't loaded more than once in the client.
<7> Making 4 unique React4XP objects from the same entry, with different props, and adding them to the chain. _They all have the same ID_ (`'this-is-not-unique'`), so they will be rendered and overwritten into the same container element - so only the last one of them survives and is visible.
<8>	So the lesson is to force the IDs to be unique, by adding a `.uniqueId()` call in each iteration. Now that the IDs are different, and they each get their own container element and all four are visibly rendered.
<9> And finally, outputting the results of the chain (although the pageContributions are skipped inside Content Studio).

[NOTE]
====
In this example we're making a new React4xp object for each rendering. An object can in principle be re-rendered, *but rendering a body or pageContribution will lock the ID* of the object.

In other words: we can use an _entry_ multiple times target1ing different container elements by using different React4XP objects. And we can render the same _React4XP object_ into the same container multiple times (if we should need to). But *trying to change the ID and target element will throw an error after an object's first rendering.*
====

=== Setup


Add this part the same way as in the previous examples and look at it in the Preview - you should see this:

[.thumb]
image:chaining2.png[title="You clicked, Sir? Why, I am but a humble screenshot!" width=1036px]

The few things worth confirming here:

* A *many-to-many relationship*: all of the entries and React4xp objects were visualized by a single part here. And some of the entries have been used in other parts and across several React4xp objects.
* This is but a humble screenshot, but in the actual Preview outside of Content Studio, the green rendered `BuilderClicker` instances are now *active* and respond to clicks as defined in `BuilderClicker`: clicking the first or second half of each of them doubles the clicked text (this activation happened in the `.hydrate` steps for server-side rendered entries, and in the actual rendering for client-side rendered ones).
* The clicks and reponses are *isolated* to the instance that was actually clicked: even though they are technically the same entry `BuilderClicker`, they each have their own state. This is not because `BuilderClicker` is nested differently in them, but because their ID's are different,
* There's only one "...repeated thing" but four "...unique thing", as explained above (point 7 and 8 in the controller code)

=== Output

*The output page source* to the client is much longer now. If you want to dive into that, it would look something like this:

.Huge page source:
[source,html]
----
<!DOCTYPE html>
<html>
    <head></head>

    <body>

        <main data-portal-region="main" class="xp-region">
            <div data-portal-component-type="part" class="chaining-example">
                <h1>04 - Chaining Example</h1>
                <p>These two target containers existed in the HTML:</p>

                <div id="a-target-container"> <!--1-->
                    <div class="builderclicker-entry" data-reactroot="">
                        <div class="builderclicker">
                            <h3 style="color:green">
                                <span style="cursor:pointer" class="first">Click</span>
                                <span style="cursor:pointer" class="second">ME!</span>
                            </h3>
                        </div>
                    </div>
                </div>

                <div id="another-target-container"></div> <!--1-->

                <hr style="display:block; margin:20px; width:100%; height:1px; border:0; border-bottom:1px dotted #aaa;"/>
                <p>The rest of the containers don't exist before rendering, but are generated and inserted at the end:</p>
                <br/>

                <div id="a-third-container-doesnt-exist-but-will-be-generated">  <!--2-->
                    <div class="builderclicker-entry" data-reactroot="">
                        <div class="builderclicker">
                            <h3 style="color:green">
                                <span style="cursor:pointer" class="first">Here I am.</span>
                                <span style="cursor:pointer" class="second">Again.</span>
                            </h3>
                        </div>
                    </div>
                </div>

                <div id="this-is-not-unique">  <!--3-->
                	<p data-reactroot="">Hello <!-- -->fourth repeated thing<!-- --> !</p>
                </div>

                <div id="this-id-is-unique_82264525">
                	<p data-reactroot="">Hello <!-- -->first unique thing<!-- --> !</p>
                </div>
                <div id="this-id-is-unique_92592361">
                	<p data-reactroot="">Hello <!-- -->second unique thing<!-- --> !</p>
                </div>
                <div id="this-id-is-unique_73808051">
                	<p data-reactroot="">Hello <!-- -->third unique thing<!-- --> !</p>
                </div>
                <div id="this-id-is-unique_54219185">
                	<p data-reactroot="">Hello <!-- -->fourth unique thing<!-- --> !</p>
                </div>
            </div>
        </main>

        <script src=" (...) /react4xp/externals.88e80cab5.js"></script>
        <script src=" (...) /react4xp-client/"></script>
        <script src=" (...) /react4xp/myChunk.b26b22ea4.js"></script>  <!--4-->

        <script src=" (...) /react4xp/mySubfolder/BuilderClickerEntry.js"></script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['mySubfolder/BuilderClickerEntry'],
                "a-target-container",
                {
                    "first": "Click",
                    "second": "ME!",
                    "react4xpId": "a-target-container"
                }
            );
        </script>

        <script src=" (...) /react4xp/site/parts/chaining/chaining.js"></script>  <!--5-->
        <script defer>
            React4xp.CLIENT.render(
                React4xp['site/parts/chaining/chaining'],
                "another-target-container",
                {
                    "first": "No click ME!",
                    "second": "I do the exact same thing only better!",
                    "react4xpId": "another-target-container"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/chaining/chaining'],
                "a-third-container-doesnt-exist-but-will-be-generated",
                {
                    "first": "Here I am.",
                    "second": "Again.",
                    "react4xpId": "a-third-container-doesnt-exist-but-will-be-generated"
                }
            );
        </script>

        <script src=" (...) /react4xp/site/parts/hello-react/hello-react.js"></script> <!--5-->
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'], <!--3-->
                "this-is-not-unique",
                {
                    "greetee": "first repeated thing",
                    "react4xpId": "this-is-not-unique"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'],
                "this-is-not-unique",
                {
                    "greetee": "second repeated thing",
                    "react4xpId": "this-is-not-unique"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'],
                "this-is-not-unique",
                {
                    "greetee": "third repeated thing",
                    "react4xpId": "this-is-not-unique"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'],
                "this-is-not-unique",
                {
                    "greetee": "fourth repeated thing",
                    "react4xpId": "this-is-not-unique"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'],
                "this-id-is-unique_82264525",
                {
                    "greetee": "first unique thing",
                    "react4xpId": "this-id-is-unique_82264525"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'],
                "this-id-is-unique_92592361",
                {
                    "greetee": "second unique thing",
                    "react4xpId": "this-id-is-unique_92592361"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'],
                "this-id-is-unique_73808051",
                {
                    "greetee": "third unique thing",
                    "react4xpId": "this-id-is-unique_73808051"
                }
            );
        </script>
        <script defer>
            React4xp.CLIENT.hydrate(
                React4xp['site/parts/hello-react/hello-react'],
                "this-id-is-unique_54219185",
                {
                    "greetee": "fourth unique thing",
                    "react4xpId": "this-id-is-unique_54219185"
                }
            );
        </script>
    </body>
</html>

----


Just confirming what you surely guessed would happen:

<1> While the first and third React4XP objects were server-side rendered and hydrated, the second one was client-side rendered into an empty container.
<2> Several of the containers that were output weren't defined in the original Thymeleaf template, and were only rendered because the ID wasn't found.
<3> Only one container with _"this-is-not-unique"_ was rendered for the same reason: that ID had already been inserted. So all the corresponding React4XP objects were server-side rendered into that one. This would also happen with client-side rendering! Also look further down: the client is asked to `hydrate` all four instances, which will log errors in the console since the content doesn't match.
<4> React4xp automatically traced the dependency to `myChunk.<hash>.js` and added this import to the page contributions because that's where `BuilderClicker` comes from.
<5> Although several of the generated assets are _used_ more than once, the page contributions are trimmed for duplicates so each of them are only _downloaded to the client_ once.

== Need to go deeper?

Thats _most_ of what React4XP offers. For more technical details, some corner-case features, adaptability and more complex functionality, we will shortly release on the Enonic pages a full API overview and other in-depth documentation for the library and build setup.
