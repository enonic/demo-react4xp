= React4XP project starter
:toc: right
:imagesdir: media/

image::react4xp.svg["React4xp logo" width=256px]

Build sites and apps that support client- and serverside JSX templating with the React framework, in combination with optimized asset serving and hydration - for lighting fast sites and apps.

== Introduction

React4XP integrates React with the CMS components in Content Studio, and allows reuse of JSX templates for both back-end, front-end and editorial use cases. It builds directly on top of traditional XP controllers, making JSX look like any other templating engine out there, while expanding the possibilities for single-page sites and client-side driven apps when needed.

This documentation takes you through the basic elements of React4XP and how to use the starter, helping you kickstart a React4xp project of your own.

[NOTE]
====
The starter and this guide aims for how-to, what-is and setup of React4xp with *XP 7*. An XP6-compatible version will be released shortly. If you're using XP6 and the XP6 starter, only the installation is different from XP7 - and the XP6 starter handles those differences. Using React4xp the rest of the way is identical, so *you can still use this guide for both versions.*
====

=== What is React4xp?

React4xp is a suite of tools: a library with a few companion NPM packages. They should cover many use cases, and can of course be used separately or be modified to suit your needs.

But primarily, *it's built to work together out of the box to make it as easy as possible to integrate React with Enonic XP*, by handling:

- component compilation/building,
- inserting editorial data into react components,
- isomorphic serverside and clientside rendering and hydration,
- optimizing and serving reusable asset chunks to the client side,
- component reference from anywhere

This guide focuses on the react4xp starter, which handles a full basic setup. But it can also be imported into an existing XP project - the core library docs have https://github.com/enonic/lib-react4xp/blob/master/README.md#installing-the-library[a guide for that].


== Get started

=== Create a starter project

To setup a project locally, run the following command:

  enonic project create -r starter-react4xp

Remember to create a *new XP sandbox* when completing the project wizard.

NOTE: *Don't have the Enonic CLI?* Visit the https://developer.enonic.com/start[Getting started guide] to install it.


=== Build and Deploy

To build and deploy the app, run this command from your shell:

  enonic project deploy

Accept starting the sandbox.

[NOTE]
====
To verify that your app started successfully, you should find an entry similar to this in the sandbox log:

  2019-04-09 13:40:40,765 INFO ... Application [<name.of.your.app>] installed successfully
====


== Project structure

If you're used to working with an https://developer.enonic.com/guides/my-first-webapp[ordinary] XP project with https://developer.enonic.com/templates/webpack[webpack], the structure will look familiar - the biggest news is the folder `react4xp/` under `resources/`. Your project folder should now look something like this:

.Selected files:
[source,files]
----
build.gradle <--1-->
settings.gradle <--1-->
package.json <--2-->
build/ <--3-->
src/
  main/
    resources/
      assets/ <!--4-->
      react4xp/ <!--5-->
        _entries <!--6-->
          REPLACE_ME.jsx <!--7-->
      site/
        parts/ <!--8-->
        pages/ <!--8-->
        REPLACE_ME.jsx <!--7-->
      webapp/ <!--9-->
----


<1> The gradle files are used by the build system. The starter includes some setup here: the library *lib-react4xp* and some building tasks that use webpack with configs that are fetched with NPM.
<2> `package.json` sets up NPM package import
<3> `build/` will contain output files produced by the build. All the output from the react4xp build process (along with a few housekeeping data files) will be compiled into the subfolder `build/resources/main/assets/react4xp`. These built assets are used in runtime both on client- and server side.
<4> But note that `assets/react4xp` is NOT the source of those React4xp assets! Just use `assets/` for other, general, non-react4xp static assets such as css and icons, etc.
<5> `react4xp/` is the general folder for react component source files. React4xp will look for `.js` and `.jsx` files here and in all subfolders, and compile them during build. All subfolders below this (except for `_entries` - see below) will be compiled to https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[*chunks*] with the same name as the subfolder. Put nested/reused react components in subfolders like that, and also other code imported by your components.
<6> `react4xp/_entries/` is special and magic. This is the main folder for *https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[entry components]* - react components that can be used directly by React4xp, that is, they don't need to be nested inside other react components.
<7> Two `REPLACE_ME.jsx` files: simply placeholders needed by webpack. Removed each of these when you've added one or more react source file below `react4xp/_entries/` and `site/`.
<8> Below the `site/parts/` and `site/pages/` subfolders is where you put your XP parts and pages, as always. With React4xp, *you can also put `.jsx` entry components together with your parts and pages*. This is link:#_a_shorthand_function_with_same_name_component[the easiest use case]: if they have the same name as the part/page, they are super easy to inject into the part/page from the controller.
<9> Folder containing the root webapp controller. React4xp supplies services that allow even static HTML pages to refer to and request compiled React4xp components.


== Usage

Simply put, there are *4 prototypical usage patterns*. You're not bound to use them exactly like this, and the examples below will show some more variation than this. But for clarity here's a basic overview of them:

=== A: Shorthand function with same-name component
*The easiest way* is to put one react entry sourcefile into the same folder as a part/page where it should be displayed, and let it have the same file name as the part/page (but `.JSX` extension only!).

Let the React4xp shorthand functions `.renderSafe` (for client-side rendering) or `.render` (for server-side rendering and client-side hydration) use XP's `request` and `getComponent()`. Add some props the same way you would add a model when rendering Thymeleaf, and/or tweak the rendering functions with extra parameters if you want.

The output from these render functions is *a full response object with everything the client needs to display it* - HTML and page contributions. Just return it directly from the controller.

=== B: JsxPath references
If you want to *reuse an entry component in multiple parts or pages* (or just, not be bound by the parent part/page folder): put a source file where you want:

  - either a `.JSX` file in any page/part folder under `site/`,
  - or a `.JS`/`.JSX`/`.ES6` under `react4xp/_entries`.

...and use `.render` or `.renderSafe`, but with the jsxPath string instead of the `getComponent` object.

During build, React4xp uses the location of all components to derive a name for each of them: the https://github.com/enonic/lib-react4xp/blob/master/README.md#jsxpath-how-to-refer-to-a-react4xp-component[jsxPath]. This can be used anywhere with the React4xp functions.

NOTE: JsxPaths are not OS paths that can be used relatively. They are *name strings, and must be used in full*.

TIP: You can see all the built jsxPaths in `build/resources/main/assets/react4xp/entries.json`.

=== C: React4xp data objects
If you need *more flexibility and control*, want to insert logic or extract data while constructing the component, or want to *use more than one entry component in a single part or page* - or even use the same react component more than once:

Instead of using the shorthands `.render` or `.renderSafe`, create a temporary data-holding `new React4xp(...)` object in the page/part controller. Use a component or jsxPath argument to point to the react component. When you're done manipulating data, the React4xp object has built-in and specific methods for rendering a body and the necessary page contributions, for client-side or server-side react rendering.

These rendering methods can be *chained*, so that the output HTML or page contribution from one object is the input for the next one. This way, one response object can be built from several react components.

=== D: Client-side exposed services
Finally, React4xp can be *used outside of the page/part flow*, even without making XP controllers if needed. A few services are exposed in runtime, where a client can request runnable compiled code:

  - entries, by jsxPath reference,
  - chunks (and lists of chunks), referred by the jsxPath(s) used on a page,
  - a client-side React4xp wrapper, simplifying these manual clientside steps and triggering rendering,
  - React and ReactDOM themselves, the versions used on the serverside. Handy if you're doing SSR and want to be sure it's always the exact same versions doing the rendering everywhere.

This allows you for example to bypass Content Studio if you want, using XP's webapp functionality, making single-page react apps etc.



== Examples

These examples can be downloaded by checking out the https://github.com/enonic/starter-react4xp/tree/examples[examples branch of starter-react4xp].

=== 1: Hello World

Let's make a simple XP part that contains a react component: `01-minimal-example`, which will be rendered entirely at the client side:

.site/parts:
[source,files]
----
/01-minimal-example/
  01-minimal-example.xml
  01-minimal-example.jsx
  01-minimal-example.es6
----

The part definition has nothing exciting going on:

.01-minimal-example.xml:
```xml
<part>
  <display-name>01 - Minimal Example</display-name>
  <description>Simple client-side example</description>
  <form />
</part>
```

The react component is plain and boring too - just receiving and greeting a `greetee` prop:

.01-minimal-example.jsx:
```jsx
import React from 'react';

export default (props) => <p>Hello {props.greetee}!</p>;
```

The controller, though, is where things happen:

.01-minimal-example.es6:
```ecmascript
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const component = portal.getComponent();
    const props = { greetee: "world" };

    return React4xp.renderSafe(request, { component, props });
};
```

// request is used to determine viewing mode. RenderSafe will aim for client-side rendering outside of XP Content Studio's edit mode, and attempt
    // non-hydrated SSR for the edit mode (falling back to a placeholder if SSR fails).
    // Component is used to extrapolate a container/react-component ID and the path to target the jsx file in the same part folder, with the same name.


`.renderSafe` takes care of three things:

- Once it gets a `.component` data object, and there's a JSX file with the same name as the controller, it can find the JSX file on its own and

do without an HTML view file and construct the target container from scratch, into which the react component is rendered. This is now the parts entire view.

We're doing without an HTML view file in the part for now, just letting `.renderSafe` detect that there  Inserts simple, hard-coded props to the React component, and
// uses XP component (getComponent) to refer to the React component in the same part folder and with the same name (example.jsx)


==== Simple client-side rendering

=== 2: Serverside rendering

==== JsxPath

==== Target container element in DOM

==== Passing editorial data to props

=== 3: React4xp objects

==== Rendering and returning body and page contributions

==== _entries

=== 4: Chaining

==== Nesting

==== Multiple instances of the same react component in one part

=== 5: Webapp

==== Services

==== The React4xp client-side object

==== The wrapper: React4xp.CLIENT

=== 6: Content Studio

==== Adding and using parts

==== Rendering in different modes

To see your current application:

. log in to the XP admin console (http://localhost:8080)
. open the "Applications" app, and select the listed applications
. visit the app by clicking the web app link.







== API and details

Link to lib-react4xp

=== API

=== Imports and chunks
When building your react components, *you can import JS/ES6 code as usual*: nested react components, your own secondary code, other frameworks, libraries, whatever... Imported code can be compiled into separate asset chunks from the entries that use them, for https://webpack.js.org/guides/code-splitting/[code splitting].

This chunking is easy to control: *put the imported sources in chunk-named subfolders below the `react4xp/` folder* (outside of `_entries`). Done this way, React4xp will handle:

 - optimized building and serving of the entries and chunks,
 - client-and-server-side caching with cache busting,
 - keep track of exactly which secondary chunks are needed for displaying which component entries,
 - and add the necessary client-side script requests/imports along with the response.

https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[More about entries and chunks in the core library documentation].

TIP: Chunks are more optimized than entries. Ideally, keep the served entries slim and leave the heavy lifting to chunks.

=== Gotchas

=== Adjusting the setup

adjusting pieces of the build
	webpack.configs from NPM packages
	constants: project structure
	externals, mtp SSR
	packages and versions

