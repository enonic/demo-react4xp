= Server side JSX with React4XP
:toc: right
:toclevels: 1
:imagesdir: media/


[NOTE]
====
**UPDATED {docdate}:** multiple adaptations for starter and lib version 1.0.0.

This documentation expects basic knowledge of React, XP and Webpack.

* https://reactjs.org/tutorial/tutorial.html[the official intro to React]
* https://developer.enonic.com/start[the Enonic XP developer portal].
* https://webpack.js.org/guides/getting-started/[webpack documentation].


====



== Introduction

This tutorial will show you step-by-step how to build XP sites and apps with React rendering, helping you kickstart a React4xp project of your own.

During this exercise you will:

- set up the starter and meet the React4xp library,
- learn how to use it to render a basic React component from any regular XP controller,
- inject editorial data into your React component,
- see how to point the controller to the React components - and where to put them in your project source,
- dig a little deeper into ways of controlling the rendering,


== React4XP

image:react4xp.svg[title="React4xp logo",width=256px]

This starter is based on *React4XP*, which is a library (with a companion build structure) that facilitates use of React in Enonic XP, and:

* enables you to use JSX as a templating language, similar to other XP templating engines
* supports isomorphic client- or serverside rendering and hydration,
* handles build flow and compilation with automated optimized asset serving
* is modular and tweakable, making it possible to pop the hood, pick it apart and set things up your own way. Godspeed!
* is flexible enough to cover many advanced use cases,


== Setup

=== Create project

Set up the starter project locally. With Enonic XP 7, run the following command:

[source,bash]
----
enonic project create -r starter-react4xp
----

Remember to create a *new XP sandbox* when completing the project wizard.

[TIP]
====
*Don't have the Enonic CLI?* Visit the https://developer.enonic.com/start[Getting started guide] to install it.

*Only want to inject react4xp into your own XP project?* The https://github.com/enonic/lib-react4xp/blob/master/README.md[lib-react4xp docs] have a section on how to do without the starter. But it's recommended to go through this introduction first.
====

{zwsp} +

=== Project structure

If you're used to working with a typical XP project using https://developer.enonic.com/templates/webpack[webpack], the structure in your project root folder will now look familiar -
the biggest news is `react4xp.properties` and the folder `resources/react4xp/`.

TIP: This is just an overview, no need to know it by heart to get started - we'll get back to all of these in more detail. For the most impatient, the takeaway is: *put your JSX source files somewhere below `react4xp/entries/` or `site/`*.

[source,files]
----
build.gradle                <--1-->
gradle.properties
settings.gradle
package.json

react4xp.properties         <--2-->

src/
  main/
    resources/
      react4xp/             <!--3-->
        entries/
        shared/

----

<1> A set of gradle config files and `package.json`. These define the build process and project structure, and in particular, make sure that the *lib-react4xp library* and *react4xp npm package* are installed right.
<2> `react4xp.properties`: tune the most common properties of the react4xp project.
<3> The `react4xp/` folder is opt-in: can be ignored for now, and doesn't need to contain anything. But when fine-tuning the build later in the tutorial, we'll get back to why you might find it handy to have a separate place for some of your react components (in ultra-short: the `entries\` folder is for react components that can be used directly by react4xp, the `shared\` folder is for common components imported by, and shared between, the entries).


{zwsp} +

=== Build and Deploy

To build and deploy the starter app, run this command from your shell:

[source, bash]
----
enonic project deploy
----

Accept starting the sandbox.

[NOTE]
====
To verify that your app started successfully, you should find an entry similar to this in the sandbox log:

`2019-04-09 13:40:40,765 INFO ... Application [<name.of.your.app>] installed successfully`
====

{zwsp} +
{zwsp} +

Now you're ready to get started with the *6 example lessons* - starting from the basics:

- link:#hello_react_page[1: Hello React: server and clientside]
- link:#editorial_props[2: Editorial props]
- link:#xp_pages_parts[3: XP pages, parts and regions]
- link:#free_structure[4: Free source file structure]
- link:#custom_flow[5: Custom flow]
- link:#imports_chunks[6: Imports and dependency chunks]


{zwsp} +
{zwsp} +

[[hello_react_page]]
== 1: Hello React: server and clientside

React4xp is made to cover many ways of combining XP and react. Let's start with a simple scenario: just displaying a working react component in content studio. We'll first do that in the serverside rendered way (this is the react4xp default). And afterwards add an option flag that turns the rendering into clientside-rendering instead.

We'll do this by adding a regular XP page controller we'll call _hello-react_:

.Files involved:
[source,files]
----
site/pages/hello-react/
  hello-react.xml
  hello-react.jsx
  hello-react.es6
----

These files are not included in the starter - use your copy/paste skills and remember that `hello-react` must be identical between file names and folder name.

{zwsp} +

=== Code

First, we need a *page definition* XML file. Just XP boilerplate:

.hello-react.xml:
[source,xml,linenums,options="nowrap"]
----
<page>
  <display-name>Hello React</display-name>
  <description>Super simple example</description>
  <form />
</page>
----

Next, we'll add the *react component*. This displays a "Hello world" heading, and we'll add some simple functionality to it: every time you click the message, it will update a number in the next line and print a message in the console. This is to show that we're rendering an _active_ react component; we're not only using JSX as an XP templating language for static HTML - although sure, you could do that too if you want.

Obviously, the actual updating step is done with vanilla JS instead of actual react, just to keep everything as simple as possible. We'll look at stateful/dynamic components later.

.hello-react.jsx
[source,javascript,options="nowrap"]
----
import React from 'react';

let bottleCount = 99;
function dropBottle() {
    bottleCount--;
    console.log(bottleCount, 'bottles of beer on the wall.');
    document.getElementById('counter').innerText = bottleCount;
};

export default (props) => <div onClick={dropBottle}>
    <h1>Hello world!</h1>
    <p>Click me: <span id="counter">{bottleCount}</span> bottles of beer on the wall.</p>
</div>;
----

[NOTE]
====
One thing is mandatory for this to work, shown in the last line: the JSX file *must default-export a function* that *_may_ take a props object* and *_must_ return a react component*. More on this link:#entries[later].

Apart from that, you can use ordinary ES6 and import and nest other JS, react components and third-party stuff from node_modules in the regular way (there is a caveat or two here. We'll get back to that too later).
====
Finally, we'll add a bare-bone *page controller* that calls the rendering engine:

[[first_helloreact_jsx]]
.hello-react.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');       // <1>

exports.get = function(request) {                       // <2>
    const entry = portal.getComponent();                // <3>
    const props = null;

    return React4xp.render(                             // <4>
        entry,
        props,
        request,
        {
            id: "react4xpApp",                          // <5>
            body:                                       // <6>
                `
                    <html>
                        <head></head>
                        <body class="xp-page">
                            <div id="react4xpApp"></div>
                        </body>
                    </html>
                `
        }
    )
};
----




That's it.

If you've used XP before, you'll probably note that there's no HTML view file, no `thymeleaf.render`, and so on - in this example, react4xp completely handles the page view. The essential thing here is that at the end of the `get` function, *react4xp in a single _.render_ call creates a _full_ XP response object that makes react work.*

What's going on in the controller?

<1> In line 2, `React4xp` is imported from the library.
<2> In line 4, we pick up the `request` data. The render call needs it to know the rendering context.
<3> In line 5, we get the XP component data. Used directly in the `.render` call, it's a convenient shortcut for react4xp to "this XP component", for finding the same-name react component in the same folder: _hello-react.jsx_. React4xp has more ways to refer to react components, or _entries_ (we'll get to that under link:#_react4xp_render[the render call] and link:#jsxPath[jsx paths]).
<4> In line 8, the juicy bit: *the actual render call*. The rendered response from it can be returned directly from the `get` function, since `.render` creates an object with a `body` HTML string and a `pageContributions` attribute with everything needed (more about this link:#_react4xp_render[below]).
<5> In line 13, the `id` attribute _"react4xpApp"_ is set in the *options* argument of `.render` (lines 12-20). This is the unique ID we're giving to the react component, and the HTML id of the target element where react will render the component in the end. Note that the same ID is found in an element in the HTML `body`:
<6> In lines 14-19, we're hardcoding a `body` option, an HTML string as a base for the output, with a _"react4xpApp"_ ID element. In many cases you can do without this string but here it's needed for the output, since react itself doesn't like to render the tags `<html>`, `<head>`, `<body>` or anything outside of a containing root tag (such as `<!DOCTYPE html>`).

{zwsp} +

[[first_setup_render]]
=== Setup and first render

If you've added those 3 files, let's get this rendered! If you've used XP and Content Studio before, this is all run-of-the mill:

1. Compile the project (`enonic project deploy` in a terminal from root) and start the sandbox (`enonic sandbox start`),
2. Navigate your browser to `localhost:8080/admin`. Log in to XP and open Content Studio (if you haven't already, you'll need to link:https://market.enonic.com/vendors/enonic/content-studio[install Content Studio] in XP).
3. Create a new Site content and Edit it in a new tab. Add your react4xp app (_"starter-react4xp"_?) on the upper left.
4. Select the new _Hello-react_ page controller in the preview panel on the right. Store that change (and refresh the page if needed).

You should now see something like this:

[.thumb]
image:hello_cs.png[link="media/hello_cs.png",title="Editing in Content Studio: Hello World. Click to see a high-res version", width=600px]

{zwsp} +

[start=5]
5. Click _Preview_ on the top to open a new tab and view the content outside of Content Studio:

[.thumb]
image:hello_bottles.png[link="media/hello_bottles.png",title="Rendering: Hello World and some bottles on a wall somewhere. Bet you clicked this screenshot, didn't you?", width=600px]

{zwsp} +

Clicking somewhere on the rendered text in the preview window will trigger the `dropBottle` function from _hello-react.jsx_, and modify the DOM and output a message in the browser console. Look at those bottles go!

{zwsp} +

[[static_cs_rendering]]
==== Two notes on the rendering before we move on:
====
*STATIC RENDERING IN CONTENT STUDIO*

If you clicked the rendering _inside XP Content Studio_ instead of a preview tab, you'd notice there was *no bottle-counting*. This is on purpose: react functionality may intervene with the Content Studio editorial workflow, or even disrupt Content Studio itself. Therefore, the `request` argument is used in `React4xp.render` to handle this automatically: inside Content Studio, you'll only see the rendering as a regular static XP preview / placeholder instead of active react.

NOTE: Later, we'll look at two other rendering functions: `.renderBody` and `.renderPageContributions`. These are intended for use cases where it's good to be more explicit than `React4xp.render`. For that reason, they _don't automatically handle this for you_. Usually, you should still keep your components from being client-activated inside Content Studio, but you'll have to handle it yourself. link:#custom_flow[Example 4 shows you how].
====

{zwsp} +

====
*SLOW FIRST SERVERSIDE RENDERING*

You may also have noticed that it took a few seconds for the very first rendering to be displayed, either here or in the edit/browse mode in Content Studio. That's the *Nashorn server-side rendering engine warming up*. It reads and caches the basics (notably, some necessary polyfilling, react and react-dom) for performance.

We're looking into mitigating this delay in the future, but for now, this is nice to know: *This delay only happens when your app is restarted*, i.e. you restart XP entirely, or redeploy the app. Setting up a continuous build with XP devmode instead, helps. For the react4xp starter, here's how:

`enonic sandbox start <yourSandBoxName> --dev` in one terminal (from anywhere), and

`enonic project deploy && gradlew react4xp_components compileXP -t` from project root in another terminal. Reply _No_ if it asks you to start the sandbox here.
====

{zwsp} +

[[hello_output]]
=== Output

Okay, back to the rendering of the page. Open the *page source* code in the browser. Here's what `React4xp.render` created - the response the client receives on the initial page request:

[source,html,options="nowrap"]
----
<html>
<head></head>
<body class="xp-page">

    <div id="react4xpApp">
        <div data-reactroot="">                     <!--1-->
            <h1>Hello world!</h1>
            <p>Click me: <span id="counter">99</span> bottles of beer on the wall. </p>
        </div>
    </div>

    <script src="(...your.app.service) /react4xp/externals.489d97cdf.js"></script>      <!--2-->
    <script src="(...your.app.service) /react4xp-client/"></script>                     <!--3-->
    <script src="(...your.app.service) /react4xp/site/pages/hello-react/hello-react.js"></script>  <!--4-->
    <script defer>
        React4xp.CLIENT.hydrate(                                                        <!--5-->
            React4xp['site/pages/hello-react/hello-react'],
            "react4xpApp",
            null,
            1, 0);
    </script>
</body>
</html>
----
We can see this whole output is actually the `body` HTML string we passed into the `React4xp.render` call in the controller - but *a lot has been inserted*. Most importantly, three assets are loaded into the client.

(The asset URLs are shortened for readability, and because some details may vary. At my computer for example, the `(...your.app.service)` part actually looks like: `/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/`)

<1> At the top, we see the `<div id="react4xpApp">` target container, now filled with a server-side rendering of the react component. At this point it's only static markup, but it will be activated during step 5 below.
<2> The first asset is `externals.<contenthash>.js`: this is react and react-dom bundled together. They are served from XP instead of from a CDN. If you want to read more about why, or how to tweak the externals, see the link:https://www.npmjs.com/package/react4xp-runtime-externals[externals docs on NPM].
<3> The second loaded asset is a client-wrapper, available in the browser's namespace as `React4xp.CLIENT`. For more, see the link:https://www.npmjs.com/package/react4xp-runtime-client[client wrapper docs on NPM].
<4> The third asset is the compiled version of _hello-react.jsx_, with the react component and the `dropBottle` routine. During `React4xp.render`, react4xp used the `component` data to locate this asset _after_ compiling. The react component gets an identifier string, `site/pages/hello-react/hello-react`, which is called a _jsxPath_ in react4xp. We'll link:#jsxPath[cover jsxPaths in more detail later], but for now you just need to know that this identifier is also used when loading this asset into the the browser's namespace: `React4xp['site/pages/hello-react/hello-react']`.
<5> Finally, the trigger. The CLIENT wrapper calls link:https://www.npmjs.com/package/react4xp-runtime-client#hydrate[hydrate] to activate react in the serverside-rendered asset `React4xp['site/pages/hello-react/hello-react']` in the target container `"react4xpApp"`. Now the `dropBottle` function works! We haven't added any props yet, hence the `null` argument. The final two digits `1, 0` are internal react4xp housekeeping, flagging some possible need for client-side postprocessing.

NOTE: The assets are served by lib-react4xp services. Most of them (_react4xp-client_ and the content-hashed assets) are optimized for client-side caching, to minimize repeated requests.

{zwsp} +

=== Client-side rendering

Sometimes you might want or need to skip the server-side rendering of a react component, and relay the react rendering entirely to the browser. This a one-line operation in `React4xp.render`. Let's return to *the controller*:


.hello-react.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const entry = portal.getComponent();
    const props = null;

    return React4xp.render(
        entry,
        props,
        request,
        {
            id: "react4xpApp",
            body:
                `
                    <html>
                        <head></head>
                        <body class="xp-page">
                            <div id="react4xpApp"></div>
                        </body>
                    </html>
                `,
            clientRender: true                          // <1>
        }
    )
};
----
<1> On the server, a truthy `clientRender` flag in the _options_ object makes the server skip the HTML rendering (in _this_ particular `.render` call. Mixing up clientside and serverside rendering across different places hasn't been tested very much, but it should work fine).

If you compare with link:#hello_output[the serverside-rendered example], the `clientRender` flag causes the *rendered output* to change slightly, changing the behavior in the browser.

[source,html,options="nowrap"]
----
<html>
<head></head>
<body class="xp-page">

    <div id="react4xpApp"></div>    <!--1-->

    <!--2-->
    <script src="(...your.app.service) /react4xp/externals.489d97cdf.js"></script>
    <script src="(...your.app.service) /react4xp-client/"></script>
    <script src="(...your.app.service) /react4xp/site/pages/hello-react/hello-react.js"></script>

    <script defer>
        React4xp.CLIENT.render(     <!--3-->
            React4xp['site/pages/hello-react/hello-react'],
            "react4xpApp",
            null,
            1, 0);
    </script>
</body>
</html>
----
<1> As expected, the target container is no longer filled with a serverside-rendered HTML representation of the react component. Instead, the browser fills in the DOM from scratch in step 3 below.
<2> The compiled assets and their URLs are exactly the same as in the serverside version.
<3> The trigger is changed: the `React4xp.CLIENT` wrapper calls link:https://www.npmjs.com/package/react4xp-runtime-client#render[render] and makes the browser build the DOM inside the target element from scratch (instead of calling `React4xp.CLIENT.hydrate`, which activates/replaces existing HTML). The function signatures of `React4xp.CLIENT.render` and `React4xp.CLIENT.hydrate` are identical.

NOTE: As link:#static_cs_rendering[mentioned before], this only applies _outside_ of Content Studio. The `clientRender` flag does not change anything inside Content Studio: still server-side rendered static HTML.

Apart from these differences behind the scenes, the page will look and behave the same when presented to the user.

Finally, it's worth mentioning a special case where you might want to _temporarily_ clientside-render a component:

[TIP]
====
You might get _serverside runtime errors_ in the react components that you write. The Nashorn rendering engine will dump an error message and some suspected code in the server log - but it's not always easy to make sense of those.

Often, switching over to _clientside rendering_ for that particular react component, will give you a better/sourcemapped error message in the browser console, making your debugging life easier.
====

Okay, ready for the next example lesson?

{zwsp} +
{zwsp} +

[[editorial_props]]
== 2: Editorial data and props

Here we'll spice up our react component a little bit by using `props` to insert editorial data from XP into the react component.

We'll modify the same files you created above:

.Files involved:
[source,files]
----
site/pages/hello-react/
  hello-react.xml
  hello-react.jsx
  hello-react.es6
----

{zwsp} +

=== Code

Now let's change the files some more so we can use Content Studio to input some data into the react rendering.

We start with some standard XP procedure: defining the data in the *page definition* XML file. This file is the same as in example 1, but we're adding a few link:https://developer.enonic.com/docs/xp/stable/cms/input-types[input fields] under `<form>`. `greeting`, `greetee`, `counted` and `startCount` are the basis for the initial props of the react component:

.hello-react.xml:
[source,xml,linenums,options="nowrap"]
----
<page>
  <display-name>Hello React</display-name>
  <description>Editorial example</description>
    <form>
        <input type="TextLine" name="greeting">
            <label>What's the greeting?</label>
            <default>Hello</default>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input type="TextLine" name="greetee">
            <label>Who shall we greet?</label>
            <default>world</default>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input type="TextLine" name="counted">
            <label>What are the things on the wall?</label>
            <default>bottles of beer</default>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input type="Long" name="startCount">
            <label>How many of them are there?</label>
            <default>99</default>
            <occurrences minimum="1" maximum="1"/>
        </input>
    </form>
</page>
----

Next, we'll modify the *react component* so that it displays data from a `props` object, instead of hardcoding everything.

[[hello_react_jsx_modified]]
.hello-react.jsx
[source,javascript,options="nowrap"]
----
import React from 'react';


function makeThingDropper(droppableProp, initialCountProp) {
    let currentCount = initialCountProp;
    return () => {
        currentCount--;
        console.log(currentCount.toString(), droppableProp, 'on the wall.');
        document.getElementById('counter').innerText = currentCount;
    };
}

export default (props) => {
    const dropThing = makeThingDropper(props.droppableThing, props.initialCount);
    return (
        <div onClick={dropThing}>
            <h1>
                {props.message} {props.messageTarget}!
            </h1>
            <p>
                Click me: <span id="counter">{props.initialCount}</span> {props.droppableThing} on the wall.
            </p>
        </div>
    );
}
----

[TIP]
====
`props` are of course the standard react way to do this. It all is. As long as a _props => reactComponent_ function is default-exported, react4xp accepts standard valid ES6/JSX.

Although, if you think that the _makeObjectDropper_ closure thing is a strange way to do something react itself could do better... I can't argue with that. Just trying to stay focused on one thing at a time.
====

And lastly, we'll hook them together: modify *the controller* to fetch the data we defined in XML, then use a `props` object to inject the data into the react component:

[[controller_with_props]]
.hello-react.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');


exports.get = function(request) {
    const entry = portal.getComponent();

    const content = portal.getContent();                    // <1>
    const pageConfig = (content.page || {}).config || {};

    const props = {                                         // <2>
        message: pageConfig.greeting,                       // <3>
        messageTarget: pageConfig.greetee,
        droppableThing: pageConfig.things,
        initialCount: pageConfig.startCount
    };

    return React4xp.render(
        entry,
        props,                                              // <4>
        request,
        {
            id: "react4xpApp",
            body: `
                <html>
                    <head></head>
                    <body class="xp-page">
                        <div id="react4xpApp"></div>
                    </body>
                </html>
            `
        }                                                   // <5>
    )
};

----

<1> Fetching the content data defined in the XML (and in the next line, we're unpacking it into `pageConfig` while choosing that missing data should just display emptiness, not throw an error).
<2> The `props` object is just any standard JS object. So the data can of course come from anywhere you want and take any shape - with one exception: `props` needs to be *serializable*, so functions can't be passed here!
<3> Connecting the field names in `pageConfig` from _hello-react.xml_ to the prop names that _hello-react.jsx_ needs.
<4> See how this makes the first two arguments of `React4xp.render` analogous to XP's `thymeleaf.render` template engine? The first argument, `entry`, is just a reference to what should be rendered (_react component_ ~ _template_), and the second one is a collection of data injected into it (_props_ ~ _model_).
<5> To keep things simpler and clearer, just remove the `clientRender` flag from the previous example.

There it is, now let's take a look!

{zwsp} +

=== Setup and rendering

Compile the project, enter Content Studio Repeat (the first two steps in link:#first_setup_render[the previous setup]), and edit the content you created (double-click it to open a new tab).

You should still see it in the preview panel on the right (although, since you probably created the content without any data created along with it, it might not display much of the text. We'll fix that):

[.thumb]
image:hello_cs.png[link="media/hello_cs.png"title="Editing Hello World, same as before. Click to see a high-res version", width=600px]

{zwsp} +

Now, when you click the preview panel, the page-config editing panel should open on the right, with the data fields containing the default text we defined. Once you click Apply/save, the preview panel to the left should update.

[.thumb]
image:hello_editorial.png[link="media/hello_editorial.png",title="Editing Hello World in the page-config panel in Content Studio. Click to see a high-res version!", width=600px]

{zwsp} +

So now, it looks the same as before, but with editorial data instead of hardcoded text. Boring, and too similar to the previous example; just repeating "Hello World" might cause a little confusion. *Try adding your own data in the fields*, for example changing _"world"_ into _"link:https://montypython.fandom.com/wiki/Bruces_sketch[Bruce]"_ etc, to keep it clear.

*Apply/save* your new props, and the output should change again. But since we're still in Content Studio, it's justa static serverside-rendered update. To see the final rendering with your new data, all active, click _Preview_ on the top to open the page in a fresh tab:

[.thumb]
image:gday_bruce.png[link="media/gday_bruce.png",title="Rendering: G'day Bruce. This is turning into one big philosophers' joke, isn't it?", width=600px]

{zwsp} +

=== Output

So did anything change in the rendered response, compared to link:#hello_output[the first serverside-rendered example]? Not all that much, actually. Depending on what data you inserted and the resulting `props`, your page source should look something like this:

[source,html,options="nowrap"]
----
<html>
<head></head>
<body class="xp-page">

    <!--1-->
    <div id="react4xpApp">
        <div data-reactroot="">
            <h1>G'day<!-- --> <!-- -->Bruce<!-- --> !</h1>
            <p>Click me: <span id="counter">42</span> <!-- -->tubes<!-- --> on the wall.</p>
        </div>
    </div>

    <!--2-->
    <script src="/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/react4xp/externals.489d97cdf.js"></script>
    <script src="/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/react4xp-client/"></script>
    <script src="/admin/site/preview/default/draft/hello-react/_/service/com.enonic.app.react4xp/react4xp/site/pages/hello-react/hello-react.js"></script>

    <script defer>
        React4xp.CLIENT.hydrate(
            React4xp['site/pages/hello-react/hello-react'],
            "react4xpApp",
            {                           <!--3-->
                "message": "G'day",
                "messageTarget": "Bruce",
                "droppableThing": "tubes",
                "initialCount": 42,
                "react4xpId": "react4xpApp"
            },
            1, 0
        );
    </script>
</body>
</html>

----
<1> Since we removed the `clientRender` flag again, the target container `react4xpApp` comes filled from the server. But now with a rendering with _your_ texts from `props` already inserted.
<2> There's still no change in the asset URLs, but since we changed _hello-react.jsx_, the content of _hello-react.js_ has of course been recompiled.
<4> The `props` are used in the clientside `.hydrate` call. For convenience, the `id` is automatically added as the `react4xpId` prop. Handy for use cases where a react component needs to uniquely identify itself.


{zwsp} +
{zwsp} +

[[_react4xp_render]]
== React4xp.render

Now might be a good time to take a closer look at the `.render` call from the ES6 controller in link:#controller_with_props[the example above]:

====
React4xp's `.render` is a one-in-all shorthand function for a lot of use cases. Basically, take any HTML string and pass it through `.render` as a `body` option, and react4xp will insert the react component into the HTML string and add any necessary page contributions to make it all work.

{zwsp} +

*Signature*, analogous to thymeleaf's familiar `render(view, model`) signature - but with some extra parameters and a full XP response object returned:

`{body, pageContributions} = React4xp.render(entry, props, request, options);`

{zwsp} +

*Parameters:*

- `entry` (mandatory, string or component object): this is the reference to the "template", the react component to be rendered. If it's a JSX file with the same name in the same folder as an XP component, simply use the `portal.getComponent()` object here. In this example,  it's the _hello-react_ page, but you can do the same thing from part or layout controllers too. We'll come back to a more specific way to reference files anywhere in your project, under link:#jsxPath[jsx path]. By the way, a react component that is used by react4xp this way is called link:#entries[an entry].
- `props` (optional object, must be serializable): data model passed into the react component.
- `request` (link:https://developer.enonic.com/docs/xp/stable/framework/http[XP request object], kind of optional, but _mandatory for react activation_): This is to keep the component rendered static and serverside-render if the rendering happens inside XP content studio. No browser react activation (or client-side rendering) happens inside content studio, you only get a visualization from the initial `props`. Special case: if `request` is omitted/falsy, page-contributions rendering is completely skipped. Note: the .render `options` argument is still valid: the rendered static HTML is still inserted into the HTML from the added `body`, and `pageContributions` are still added.
- `options` (optional object): additional options to control the rendering:

** `id` (string): ID of the component, matching the ID of an element in `body`. React will render into that container element, replacing whatever was already there. If missing, a random ID is generated.
** `body` (string): HTML string, a base for the returned `body`. Can be a hardcoded string, or come from a thymeleaf/mustache/XSLT render, and so on. Just make sure the `id` option matches an HTML id here (what happens if not? React4xp creates a target element with that ID, last in the root element of `body`). If there's no `body` option, a matching-ID `<div>` target container is generated.

** `pageContributions` (object): you might already have some page contributions you want to return together with the ones generated by react4xp. Same way as with `body`, just add them here to pass them through `render`. Order: the ones you add here are output before the ones rendered.
** `clientRender` (boolean): if `true` (truthy, actually), the server-side rendering is skipped (in live mode and previews. Inside content studio's browser or edit modes, you still only get a static server-side rendered representation).

{zwsp} +

*Returns* an link:https://developer.enonic.com/docs/xp/stable/framework/http[XP response object] with these main attributes:

- `body`: rendered HTML string. When server-side rendered, the whole HTML is inserted into the matching-id element inside the `body` option (if the `body` option is added. If not, a surrounding `<div>` is used). When client-side rendered, no HTML is inserted into `body` (or the generated container) - that's left to the client.
- `pageContributions`: a regular link:https://developer.enonic.com/docs/xp/stable/cms/contributions[XP page contributions] object. Includes everything the browser needs to activate (or client-side render) the react component: auto-compiled assets for the entry (_hello-react.js_ in this example) and whatever it may depend on (most importantly, react and react-dom in an _externals_ asset), and a client-side react4xp wrapper asset. These are all optimized and served to the client by react4xp services.
====

`.render` is just one way. React4xp has other, more detailed and flexible ways of rendering, we'll link:#custom_flow[look at those] in a bit.



{zwsp} +
{zwsp} +

[[xp_pages_parts]]
== 3: XP Pages/Parts/Regions and Content

So far, we've used a "raw" XP Page and just rendered the react component directly from the controller there. It's fine in itself, but not really making good use of XP's excellent CMS powers. So let's move into that territory!

[TIP]
====
*TL;DR*: Naturally, this example will focus quite a bit on XP Content Studio and how to use Parts, Pages, Regions and Templates. If this is familiar to you, you can pretty much just skim through it - the key takeaways are:

  - `React4xp.render` works the same way from any controller.
  - React4xp comes with an importable `<Regions>` react component for making XP Regions
  - Each time the client calls `React.CLIENT.render` or `.hydrate` will create an independent react root app.
====

React4xp can also render from XP _Part or Layout controllers_, creating react-rendered XP elements that can be dragged into any regular XP Region. And besides, react4xp can (serverside) render these XP Regions themselves, which can then accept any XP Parts/Layouts dropped into them (as well as Fragments, Text and Image components of course).

In this example, we'll do both:

* Make a react-rendered general link:https://developer.enonic.com/docs/xp/stable/cms/components[XP Page Controller] with a working XP Region.
* Make a react-rendered link:https://developer.enonic.com/docs/xp/stable/cms/components#part[XP Part] that can be dragged into the Region.
* In addition, we'll display it in the "regular XP way": using a link:https://developer.enonic.com/docs/xp/stable/cms#page_templates[Page Template] to connect a link:https://developer.enonic.com/docs/xp/stable/cms/content-types[Content Type] to our new Page controller. This way, in this example and the next ones, we can just create content items of that type and have the Page controller up and running immediately instead of having to set it up manually each time.

.Files involved:
[source,files]
----
site/content-types/
  my-content/
    my-content.xml

site/pages/
  default/
    default.xml
    default.es6
    default.jsx

site/parts/
  color/
    color.xml
    color.es6
    color.jsx
----

[NOTE]
====
The Page controller _default_ can be made from scratch, or you can copy _site/pages/hello-react_ and change the copy (don't delete _hello-react.jsx_ just yet, we're going to re-use it link:#custom_flow[later]). If you copy and modify, just remember this as usual: name the the *folder and file names* identically.
====

{zwsp} +

=== Template with React Page Controller

==== Code: XP Content Type

We'll start with a completely generic content type: _site/content-types/my-content/my-content.xml_. Content types tend to define more than this, but for now, this is all we need:

.my-content.xml:
[source,xml,options="nowrap"]
----
<content-type xmlns="urn:enonic:xp:model:1.0">
    <display-name>My Content</display-name>
    <description>Just some content</description>
    <super-type>base:structured</super-type>
    <form/>
</content-type>
----

Again, this has nothing to do with react4xp, but it'll make the setup of this and the next examples easier.

==== Code: XP Page controller

Now we'll make the react-based Page controller: _site/pages/default/_ will be a bare-bone page with nothing but a Region in it.

*The page definition* is simple. We're now leaving the `<form>` node empty, but adding a `<regions>` node with a single `"main"` Region defined in it:

.default.xml:
[source,xml,options="nowrap"]
----
<page>
    <display-name>Default page</display-name>
    <description>React4xp-rendered Page controller</description>
    <form/>
    <regions>
        <region name="main"/>
    </regions>
</page>
----


*The react component* has a single focus, namely rendering the Region:

.default.jsx
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';
import Regions from 'react4xp-regions/Regions';    // <1>

export default (props) => (
    <div className="default-page">
        <Regions {...props} />                     // <2>
    </div>
);
----

<1> Importing a Region template from an NPM package that comes with react4xp (link:https://www.npmjs.com/package/react4xp-regions[react4xp-regions]).
<2> Nesting the Region in our component. To be precise: it uses `props.regionsData` and selects the Region name(s) in `props.names`, so it will render _all_ Regions given by `props` if more than one is defined and selected.

The `props` of course come from the *Page controller*. Still similar to the previous examples, we're mainly just adding props that are needed by `<Regions>` in the react component.

.default.es6:
[source,javascript,linenums,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const content = portal.getContent();
    const entry = portal.getComponent();

    const id = `react4xp_${content._id}`;   // <1>

    const props = {
        regionsData: content.page.regions,  // <2>
        names: "main",                      // <3>
        tag: "main",                        // <4>
    };

    return React4xp.render(
        entry,
        props,
        null,                               // <5>
        {
            id,
            body: `
                <html>
                    <head>
                        <title>${content.displayName}</title>
                    </head>
                    <body class="xp-page">
                        <div id="${id}"></div>
                    </body>
                </html>
            `
        }
    );
};
----

<1> The XP content ID is nice and unique, let's just use that to bind the react component to the target element in the DOM.
<2> Here, `content.page.regions` are content data containing the Region we defined in _default.xml_ as well as data about content dropped into it. This is mapped to the `regionsData` prop.
<3> The `names` prop can be a string or a string array. It's used to select which Regions (by Region name defined in _default.xml_) to render, in case there are more Regions in `content.page.regions`. Rendering will occur in the order of the string array. If the `names` prop is missing, all the regions defined in _default.jsx_ are rendered (so we could technically skip this prop here), but the order is less predictable if there's more than one Region.
<4> The optional `tag` prop sets which HTML tag will be at the root of the section rendered by `<Regions>`, instead of `<div>`. Here, we're going for `<main>`.
<5> We're setting the `request` argument of `React4xp.render` to _null_ - switching off the auto-handling of how _this_ particular rendering is done inside/outside Content Studio, and just forcing `React4xp.render` to *always output a static, serverside rendered HTML body without page contributions*. But why? Two reasons:
  - The way it is now, _default.jsx_ and the Regions in it has no need for page contributions. Only the static HTML is of interest; no client-side JS code needs to be activated/rendered in the client, and there's no styling or anything else coming from it. So by skipping the page contributions rendering, performance is improved a little.
  - There is a *caveat when using react4xp to render Regions* (like in _default.jsx_): currently, page contributions don't work for XP Parts/Layouts if they are dropped into a _clientside_-rendered Region. So Regions must be serverside rendered if they are meant to contain XP components that will need their own page contributions to work - for example react4xp parts, which rely on page contributions to be activated in the client). So by forcing a static serverside Regions rendering, we prevent that corner case from failing, and make sure _any_ XP element dropped inside the Region will work, even clientside-rendered react4xp parts.

TIP: Adding an XP Region to a Layout is the same, only easier: since it will be injected inside a Page, you don't need to add an outer `body` in the _options_ parameter, and therefore you don't need an `id` parameter either - same as in the XP Part controller below.

[[page_template_setup]]
==== Setting up the Template

Before we move on to the XP Part, let's bind this Page controller to the _my-content_ Content Type we just made, in the regular XP way. This lays the foundation for this example and also the later ones. When this is done, *using the _default_ Page controller will be easy*: create a new _my-content_ item in your site, and it will come out ready to use with the Region from _default_.

1. When you've deployed the updated app and logged into Content Studio, make a new Site content and connect it to the react4xp app (or re-use one of your previous ones).
2. In the grid (Content Studio browse mode), under your Site, create a new Template content under Templates:

[.thumb]
image:template_new.png[link="media/template_new.png",title="Creating a new Template content in Content Studio.", width=500px]

{zwsp} +

[start=3]
3. When editing your new Template, give it a display name, select your new content type _my-content_ in the _"Supports"_ drop-down menu on the left, and select the new Page controller _Default_ under the _"Template_" (or _"Page controller"_) drop-down menu on the right:

[.thumb]
image:template_edit.png[title="Using a Template to connect a content type to a page controller in Content Studio.", width=1024px]

{zwsp} +

[start=4]
4. Apply/save and you're done.

{zwsp} +

=== XP Part

Now we're ready to add a simple react-rendered Part to drop into the Region: _site/parts/color/_ .

==== Code

The *Part definition* pretty unremarkable now as well. There's just a `color` TextLine input field in the form:

.color.xml:
[source,xml,options="nowrap"]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<part>
    <display-name>Color part</display-name>
    <description>React4xp rendered part with editorial color</description>
    <form>
        <input name="color" type="TextLine">
            <label>What's the color of the thing?</label>
            <occurrences minimum="1" maximum="1"/>
            <default>red</default>
        </input>
    </form>
</part>
----

*The react component* only displays the color name from the props and inline-styles it with that color (as long as the `props.color` value is HTML-compliant):

[[color_jsx]]
.color.jsx
[source,javascript,options="nowrap"]
----
import React from 'react';

export default (props) => (
    <div style={{
        border: `1px solid ${props.color}`,
        margin: "8px",
        padding: "8px",
        borderRadius: "10px"
    }}>
        <p style={{color: props.color}}>Hey, I'm pretty {props.color}!</p>
    </div>
);
----

Like before, *the controller* mainly hooks the XP editorial data into the props:

[[color_part_controller]]
.color.es6:
[source,javascript,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {

    const component = portal.getComponent();

    const props = { color: component.config.color };

    return React4xp.render(
        component,
        props,
        request,
        {                               // <1>
            clientRender: true,         // <2>
            pageContributions: {        // <3>
                bodyEnd: `<script>console.log("The color of the thing is: ${component.config.color}");</script>`
            }
        });
};
----

<1> In the _options_ argument (the object with `clientRender` and `pageContributions`), notice how we're _not_ adding `body` or `id` like we did before. `body` is only needed for the controller to _add_ HTML around the rendered react - if you skip it a target container `<div>` will just be generated for you. With an autogenerated container, the ID will match either way: you can still set the ID value with the `id` _option_, or skip it and just let react4xp supply a unique ID. For details, see the link:#_react4xp_render[React4xp.render] box. For that matter, *we don't even need the options argument here at all* - it could be completely skipped...
<2> ...but for demonstrating, let's use it to show that this Part is _independent_ (from both the _default_ Page we defined a moment ago, and from any other Parts dropped into the same Region, react or otherwise), by clientside rendering the Part...
<3> ...and adding a tiny color-logging script with the Part. This is done by using the _options_ parameter to pass `pageContributions` through `.render`, the same way we've passed `body` through it so far.


{zwsp} +

[[adding_parts_to_new_content]]
=== Setup and render

Time to get this displayed and see it all in action! Again, just XP routine: creating a _my-content_ item, and since the Template makes it show up ready with a _default_ Page controller and Region, we can just drop our new _color_ Part into it.

1. As before, recompile/deploy and enter Content Studio. In the same Site as the Template you just made (but not under _Templates_), create a new _my-content_ item:

[.thumb]
image:content_new.png[link="media/content_new.png",title="Creating a new content item in Content Studio (click for high-res version)", width=500px]

[.thumb]
image:content_my.png[link="media/content_my.png",title="Selecting the new my-content type in Content Studio (click for high-res version)", width=500px]

{zwsp} +

[start=2]
2. When you edit the new content, the preview panel with a dash-bordered *_"Drop here"_ area* should appear on the right. This is the _default_ Page controller rendering the initially empty *Region*. To the far right, there should be a config panel with the _"Insert"_ tab (if you can't see them, use the screen and cogwheel icons on the top right):

[.thumb]
image:page_with_ready_region.png[link="media/page_with_ready_region.png",title="Editing new content in Content Studio, with Region ready to receive parts etc (click for high-res version)", width=500px]

{zwsp} +

[start=3]
3. Drag _"Part"_ from the config panel into the Region. In the dropdown menu (_"Type to search..."_) that appears in the Region (or the _"Part"_ dropdown menu now on the right), select your new _color_ Part. It should now appear correctly rendered in the preview panel (occasionally, you might need to _Save_ and refresh the page). And the config panel for editing the settings of that particular part should appear on the far right (if it doesn't, click the part itself: _"Hey, I'm pretty red"_):

[.thumb]
image:content_with_red_part.png[link="media/content_with_red_part.png",title="Editing new content in Content Studio, with Region ready to receive parts etc (click for high-res version)", width=500px]

{zwsp} +

[start=4]
4. Try experimenting with dragging other XP components from the _"Insert"_ tab into the Region. Say, a Text component, and/or adding another instance of the same _color_ Part but with a different (HTML-compliant) color value in the Part config panel. You'll see that the react-rendered Region accepts all regular XP components, and that multiple instances of the same _color_ Part remain independent from each other.
5. As usual, clicking _Preview_ on the top will open a new Preview tab for your page.

{zwsp} +

=== Output
We won't go into the details about the HTML output anymore - it's structurally and conceptually *the same as in the previous examples*. Looking at the _Page Source_, it should all make sense to you by now: the Page controller and Part are *compiled to separate assets and downloaded exactly once* in the client before calling `React4xp.CLIENT.render` and `.hydrate` as needed (using a react4xp Part more than once does not make the client download the assets more than once - they're recycled for performance).

NOTE: As we'll come back to in more detail link:#entries_and_jsxpath[later], each time the client calls `React.CLIENT.render` or `.hydrate`, it will create a *separate root react app*. This is the outcome for each time a controller calls `React4xp.render` with the _request_ argument (omitting _request_ forces a pure serverside rendering without hydration). So in this example, there will be one independent react app in the client for each of the _color_ Parts you added to the Region.



{zwsp} +
{zwsp} +

[[free_structure]]
== 4: Free source file structure

So far, every time we've referenced a _.jsx_ react component from react4xp in a controller, we've used a `component` object in the _entry_ argument of `React4xp.render`. This is just a shortcut, and it depends on an "XP-conventional" naming regime to work: the _.jsx_ source file must be in the same folder as the controller, and have the same name.

It doesn't have to be that way. In this example, we'll take a look at which react components are available to `React4xp.render` - called *entries* in react4xp - and how to reference them, whatever they're called and wherever they're located.

A link:#entries_and_jsxpath[detailed summary] follows after the examples.

{zwsp} +

=== Below _site/_

Below the folder _src/main/resources/site/_, all source files with the extension _.jsx_ are detected at compile-time and available as entries to react4xp. If you take the *path relative to _resources/_* and the file name without the extension, you get a string that can be used to point react4xp to that react component:

- `"site/parts/hello-react/hello-react"` -> _src/main/resources/site/parts/hello-react/hello-react.jsx_
- `"site/parts/color/color"` -> _src/main/resources/site/parts/color/color.jsx_
- `"site/parts/color/differentEntry"` -> _src/main/resources/site/parts/color/differentEntry.jsx_

...etc.

These strings are called *jsxPaths* in react4xp, and they can be used directly in controllers as the _entry_ argument. For example in the link:#color_part_controller[_color_ Part controller] from before:

.site/parts/color/color.es6
[source,javascript,options="nowrap"]
----
React4xp.render(
    component,
    props,
    request,
    options
);
----

...is equivalent to:

[source,javascript,options="nowrap"]
----
React4xp.render(
    "site/parts/color/color",
    props,
    request,
    options
);
----

And so on. Calling the _.jsx_ source file something else, or having it in a different folder, is fine as long as you refer it correctly like this.

NOTE: _jsxPaths_ are name strings, not relative paths! You can't refer to _color.jsx_ from _color.es6_ as `"color"` or `"./color"` etc.

TIP: If you look at the rendered HTML output in page source, you can see React4xp using the jsxPaths to refer to the compiled assets from the client - even if you used the `component` object in the _entry_ argument.

TIP: All the _entries_ in your project are listed with their _jsxPath_ after compilation, in _build/resources/main/assets/react4xp/entries.json_.


{zwsp} +

=== Below _react4xp/_
If you just want to keep your react components out of the regular XP file structure in _site/_ and be independent of the structure of Parts, Pages etc, the folder _src/main/resources/react4xp/_ is meant for that. Here's how (assuming you're generally following link:https://github.com/enonic/lib-react4xp/blob/0.9.0/README.adoc#setup-option-2-using-react4xp-in-an-existing-project[the recommended setup pattern] used in the react4xp starter):

Open _react4xp.properties_ in the project root, and look for the property `entryDirs`. This is a (comma-separated) list of folder names *relative to the _react4xp/_ folder*. React4xp comes with a built-in suggestion here: `entryDirs = entries`. This means that all _.jsx_ (and _.js_ and _.es6_) source files below _src/main/resources/react4xp/entries_ will become entries: react components available to react4xp.

They will get a *_jsxPath_ relative to the closest _entryDirs_ folder*.

So for example if `entryDirs = entries`, then the closest _entryDirs_ folder is _src/main/resources/react4xp/entries_, and any XP controller can render _src/main/resources/react4xp/entries/subFolder/myEntry.jsx_ like this:

[source,javascript,options="nowrap"]
----
React4xp.render(
    "subFolder/myEntry",
    props,
    request,
    options
);
----

TIP: *Under the _site/_ folder, entry source files must have the extension _.jsx_*. This is because regular XP source files can have _.js_ and _.es6_ extensions, and must be separated since the compilation and handling is very different. However, *under the _entryDirs_ folder(s), entries can have _.js_ and _.es6_ extensions too!*

NOTE: React4xp doesn't currently separate between different _entryDirs_, they behave as one. So if `entryDirs = entries,moreEntries` then _react4xp/entries/foo/bar.jsx_ and  _react4xp/moreEntries/foo/bar.jsx_ will get the same _jsxPath_: `"foo/bar"`. Beware of *namespace collisions*; you won't be able to refer to both.


{zwsp} +

=== Anywhere else

The _entryDirs_ are paths relative to _src/main/resources/react4xp/_, so just use relative _entryDirs_ if you need entries outside of that.

For example, say you've added an NPM package _externalComponents_ with react components in a _comps_ subfolder, and you want to use them as entries. Simply add it to _entryDirs_:

.react4xp.properties
[source,options="nowrap"]
----
entryDirs=entries,../../../../../node_modules/externalComponents/comps
----

(Or replace _entries_ if you're not using it, of course)




{zwsp} +
{zwsp} +

[[entries_and_jsxpath]]
== Entries and jsxPath

For reference, here are some more details about what _entries_ and their _jsxPath_ are:

[[entries]]
====

*ENTRIES*

React4xp is structured around _entries_. An entry is just *a React component that can be accessed by react4XP* in an XP controller. They are the _only_ react files that react4xp can use directly!

{zwsp} +

Entries are pretty much just standard JSX files, but they must follow *two requirements* (link:media/entries_howto.png[cheatsheet]):

1. *default-exports a function*, this function _may_ take a `props` argument (serializable JS object) and _must_ return a react component (pure functional component or old-school React Component), and
2. is located either in a folder either below *_/site/_* or below one of the *entryDirs* folders listed in _react4xp.properties_ (see also _jsxPath_ below).

{zwsp} +

Think of *entries as "bridge elements"*:

.A mental model (image links to another cheatsheet):
image:entries.png[link="media/entries_cheatsheet.png",title="React4xp Entries basic structure. Controllers can use entries, entries can import anything", width=600px]

On the XP/server side, you have the controllers with their backend XP flow, logic and XP lib imports. Entries are the beginning of the frontend side (although the same code is also used for serverside-rendering): they do regular frontend-style ES6 logic and can *import* stuff from NPM/node_modules, your own logic, nested react components, whatever - even other entries.

{zwsp} +

React4xp handles them in build-time and runtime: locates entries, compiles them into *entry assets* (under _/build/resources/main/assets/react4xp_), and serves them to the client.

Each entry becomes a separate *root level react app*. Good to know if you display more than one entry on a page - which you can, but you might also consider using just one entry for the root, and multiple imports in it.

For example, earlier in this tutorial we've seen the entries _hello-react.jsx_ and _color.jsx_, they are compiled into the assets _hello-react.js_ and _color.js_.
====

{zwsp} +

[[jsxPath]]
====
*JSX PATH*

Each entry is identified by its own _jsxPath_.

Short and brutal: the jsxPath is a name string generated from the path and filename of the compiled asset after building, relative to _/build/resources/main/assets/react4xp/_ - without file extension.

During development though, these *3 rules* are probably easier:

1. If you use the `component` object like in link:#hello_react_page[the first example], you can ignore the jsxPath. `React4xp.render` will use the component object to find an entry with the same folder/same name as a part/page/layout controller.

But if you need to access an entry from a different folder - from anywhere actually - here's *how to find the jsxPath of an entry*:

[start=2]
2. If an entry's source file is a JSX under _/src/main/resources/_ *_site/_*, the jsxPath is the source file's path relative to _/src/main/resources/_ - unix-style and without file extension.
* So the jsxPath will start with `site/...` etc (and the asset will be compiled into a folder below _/build/resources/main/assets/react4xp/_ *_site/_*, and so on).
3. Or, using the setup from the starter, you can also put your entries under _src/main/resources/_ *_react4xp/entries_*. Then the jsxPath (and compiled-asset path) will be relative to _/entries/_ instead.
* Actually, you can control this with the `entryDirs` property in _react4xp.properties_. The starter has added `entryDirs=entries` here, but this is a comma-separated list of folder names relative to _src/main/resources/react4xp/_. Remember, if you add more entryDirs or replace `entries`, the jsxPaths will always be relative to those new entryDirs.

* *For example:* add `../myComponents` to entryDirs: `entryDirs=entries,../myComponents`. Since entryDirs and the "../" are relative to _src/main/resources/react4xp/_, the new entry source folder is _src/main/resources/myComponents/_. Now new JSX files can be put there, and get a jsxPath relative to that. So the entry _src/main/resources/myComponents/_ *_app/myEntry.jsx_* will get the jsxPath `"app/myEntry"`, and will be compiled to the entry asset _/build/resources/main/assets/react4xp/app/myEntry.js_.

If you're ever unsure: after building, all the *jsxPaths of all the available entries* are stored in _build/resources/main/assets/react4xp/entries.json_. This file is generated by webpack during build. It's also used by the runtime, so it shouldn't be deleted or edited!

NOTE: jsxPaths are not actually file system paths, but *static name strings*. So avoid shortcuts and relative references like `../`, etc.

See also: the link:#chunks[chunks] info box.
====




Okay, time to move on to the next example and lesson!

{zwsp} +
{zwsp} +

[[custom_flow]]
== 5: Custom flow

In this example things get a bit more complex. We'll make another Part, and re-use the Page controller, Template and Content type we made link:#_template_with_react_page_controller[previously].

1. However, we won't use the `React4xp.render` shorthand function from before. Instead, we'll look at a more *explicit react4xp syntax*:
  - It constructs one or more *data-holding React4xp objects*. This gives you better control and opportunities for logic steps when you handle your link:#entries[JSX entry]; you can manipulate the object(s) or extract data from them _before_ rendering.
  - Here, each entry is rendered in *two separate methods*: `renderBody` and `renderPageContributions`.
  - You can pretty easily render *multiple entries* from the same controller, by chaining together their rendering.

2. We will also use a *thymeleaf* template for one of the entries - and take advantage of the react4xp data object to send its ID to the thymeleaf model - just to demonstrate a way to combine react and thymeleaf rendering.

3. In addition to chain-rendering more than one entry, we will use the _jsxPath_ link:#jsxPath[as described above] to point to entries in a *different location*. Actually, let's just recycle the entries from before:


.Files involved:
[source,files]
----
site/parts/
    custom-flow/            <!--1-->
        custom-flow.xml
        custom-flow.es6
        custom-flow-view.html

    color/
        color.jsx           <!--2-->

site/pages/
    hello-react/
        hello-react.jsx     <!--3-->
----

<1> The new Part we're making, _custom-flow_.
<2> The already existing entry link:#color_jsx[_color.jsx_]: a different folder from our _custom-flow_ Part, and different name.
<3> We're also reusing another existing entry link:#hello_react_jsx_modified[_hello-react.jsx_] (with props, not the first hardcoded one), located under _site/*pages*/hello-react/_. So even though what we're making here is a Part, an entry from a Page, or anywhere, is fine: when using jsxPaths, all entries are equal.


{zwsp} +

=== Code


*The Part definition* again defines some base data for us to play with. This is exactly the same definitions as before, just merged together into one Part: the greeting and bottle/thing counter from _hello-react.xml_, and the color from _color.xml_.

.custom-flow.xml:
[source,xml,options="nowrap"]
----
<part>
    <display-name>CustomFlow example</display-name>
    <description>Single part with multiple entries</description>
    <form>
        <input name="color" type="TextLine">
            <label>What's the color of the thing?</label>
            <occurrences minimum="1" maximum="1"/>
            <default>red</default>
        </input>

        <input type="TextLine" name="greeting">
            <label>What's the greeting?</label>
            <default>Hello</default>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input type="TextLine" name="greetee">
            <label>Who shall we greet?</label>
            <occurrences minimum="1" maximum="1"/>
            <default>world</default>
        </input>

        <input type="TextLine" name="things">
            <label>What are the things on the wall?</label>
            <occurrences minimum="1" maximum="1"/>
            <default>bottles of beer</default>
        </input>

        <input type="Long" name="startCount">
            <label>How many of them are there?</label>
            <occurrences minimum="1" maximum="1"/>
            <default>99</default>
        </input>
    </form>
</part>

----

Next, we're adding a *thymeleaf view template*:

This forms the initial HTML base, with `color` and `targetId` inserted by thymeleaf. This is actually not different from before: link:#first_helloreact_jsx[previously] we've used a hardcoded string as the HTML base that react is rendered into. Now we're just letting thymeleaf make it. Same thing, the base HTML string can come from anywhere.

The controller will render _two_ entries into this base HTML. To be clear: even though we're using two entries, this is still _one single XP Part_. The first entry is _color.jsx_ which will be inserted into the element `<div data-th-id="${targetId}"></div>`. The second one, _hello-react.jsx_ will also be rendered and inserted into this base HTML, but it will have a react4xp-ID that does not match any element ID here. This will cause react4xp to revert to the default behavior: generate a new container `<div>` and insert it right at the end of the root element: after `</section>` here:

.custom-flow-view.html:
[source,html,options="nowrap"]
----
<div class="custom-flow-view">
    <section class="color-section">
        <h2 data-th-text="|Ain't nothing but a ${color} thing|"></h2>
        <p>Here it comes:</p>
        <div data-th-id="${targetId}"></div>
    </section>
</div>
----

*The controller* now has more complexity than before, so here's an overview:

- Each entry is used to set up a data-holding reactxp object, in steps _before the rendering_ is called. In these steps, data (options and props) can be both injected into the react4xp objects, and extracted from them.
- The output of one rendering is used as the base for the next; chaining them together and gradually building up the final output.
- HTML body and page contributions are rendered separately for each entry. So there is one multi-entry flow for body, and another for page contributions.

.custom-flow.es6
[source,javascript,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

const view = resolve('custom-flow-view.html');


exports.get = function(request) {
    // Fetching data from the part config:
    const component = portal.getComponent();
    const partConfig = (component || {}).config || {};



    // Setting up the data-holding object for hello-react.jsx:
    const helloObj = new React4xp(`site/pages/hello-react/hello-react`);     <!--1-->
    helloObj.setProps({                                                      <!--2-->
            message: partConfig.greeting,
            messageTarget: partConfig.greetee,
            droppableThing: partConfig.things,
            initialCount: partConfig.startCount
        })


    // Setting up colorObj, the data-holding object for color.jsx:
    const colorObj = new React4xp(`site/parts/color/color`);
    colorObj                                                                 <!--3-->
        .setProps({ color: partConfig.color })
        .setId("myColorThing")                                               <!--4-->
        .uniqueId()                                                          <!--5-->


    // Using thymeleaf to render container HTML,
    // inserting the colorObj's ID into the target container where colorObj will be rendered:
    const thymeleafModel = {
        color: colorObj.props.color,
        targetId: colorObj.react4xpId
    }
    const colorSectionContainer = thymeleaf.render(view, thymeleafModel);    <!--6-->


    // Render the color.jsx entry into the same-ID target container in the container HTML:
    const colorBody = colorObj.renderBody({
        body: colorSectionContainer                                          <!--7-->
    });
    // Rendering the activating page contributions of color.jsx.
    const colorPageContributions = colorObj.renderPageContributions({
        pageContributions: {                                                 <!--8-->
            bodyEnd: `<script>console.log('Created: ${colorObj.props.color} thing.');</script>`
        }
    });


    // Determining if the rendering context is not inside Content Studio:
    const isOutsideContentStudio = (                                         <!--9-->
        request.mode === 'live' ||
        request.mode === 'preview'
    );


    // Rendering helloObj's entry into colorBody (which is basically custom-flow-view.html with color.jsx added),
    // using client-side rendering only outside of Content Studio:
    const finalBody = helloObj.renderBody({
        body: colorBody,                                                     <!--10-->
        clientRender: isOutsideContentStudio
    });
    // Adding helloObj's page contributions to the previously rendered page contributions,
    // duplicating clientRender between renderPageContributions and renderBody (pair-wise for each entry).
    const finalPageContributions = helloObj.renderPageContributions({
        pageContributions: colorPageContributions,                           <!--11-->
        clientRender: isOutsideContentStudio
    });


    // Finally, returning the response object in the standard XP-controller way:
    return {
        body: finalBody,
        pageContributions: finalPageContributions
    }
};

----
<1> Constructing the data-holding react4XP object `helloObj` from the _hello-react.jsx_ entry we finalized link:#hello_react_jsx_modified[before]. The constructor takes one argument, which is mandatory: an link:#entries[entry reference]. This can be an XP `component` object like before, OR like we're doing here: a link:#jsxPath[jsxPath]. This entry reference is used the same way as the first argument, _entry_, in link:#_react4xp_render[`React.render`].
<2> `setProps` modifies `helloObj`, to add some `props`. This corresponds to the second argument, _props`, in `React4xp.render`.
<3> After creating a react4xp object `colorObj` for the second entry, _color.jsx_, we're modifying that too, starting with adding props. Note the *builder-like pattern* here: each of the setter methods (`setProps`, `setId` and `uniqueId`) returns the react4xp object itself. This allows you to run them directly after each other like this, so this example is just a shorter way of writing `colorObj.setProps({ color: partConfig.color });  colorObj.setId("myColorThing");  colorObj.uniqueId();`.
<4> `setId` sets the ID of the react4xp object and the target element that the rendering will look for in the HTML. If an ID has previously been set for the react4xp object, `setId` will overwrite it.
<5> `uniqueId` makes sure the react4xp object has a globally unique ID. It can work in two ways. If an ID has not been set previously, a simple random ID is generated. If an ID _has_ been set, like here in step 4, the random number is appended after the existing ID. So the order between `setId` and `uniqueId` matters - what we get here is _"myColorThing"_ plus a random number (separated by an underscore), giving us something recognizable in the output but still ensuring that the element ID is not repeated in cases where this part is used more than once on a page. Had `setId` been run after `uniqueId`` however, `setId` would just overwrite the previous unique ID with the supplied string - and possibly repeated.
<6> So, since there's a random component in the ID string of the react4xp object and we want that ID to match a specific element in the HTML, we read the ID from `colorObj.react4xpId` and inject it into the thymeleaf template as `targetId`.
<7> We render `colorObj` into a new HTML string, based on the HTML output of the thymeleaf rendering...
<8> ...and render the page contributions for activating it in the client. We add a small extra script just to demonstrate that extra pageContributions can be added in `renderPageContributions` as well, by passing them through as before. Now we have both the HTML body and page contributions from the first entry, _color.jsx_.
<9> But we're going to add a second entry to this Part, just because we can. That entry's going to be clientside rendered (as opposed to _color.jsx_ which gets serverside-rendered because no `clientRender` was flagged). However, since this syntax doesn't automatically handle inside-content-studio rendering (unlike link:#_react4xp_render[React4xp.render] which does handle that), we need to determine if this rendering is happening inside or outside Content Studio.
<10> Rendering the HTML body of second entry, _hello-react.jsx_, into the HTML body from the first entry: `colorBody` from before. ID and target element is handled the same way as in `React4xp.render`: since no ID is set (we created `helloObj` without running `.setId`) a random ID will be used. And since that ID doesn't match any ID in the base HTML `body` (`colorBody`), the rendering will just create a target container element inside the root element of `colorBody`, after other content. We're letting the value of `clientRender` depend on whether or not we're rendering inside Content Studio (if we are, then `isOutsideContentStudio` is `false` and serverside-rendering is forced, while we get clientside rendering outside).
<11> Rendering the activating page contributions for `helloObj`, adding them to the previous `colorPageContributions` by passing them through the rendering. We're using the same `clientRender: isOutsideContentStudio` here too:

[NOTE]
====
*The rendering mode (client- or serverside) must match* between `renderBody` and `.renderPageContributions` for an entry!

This is on an entry-by-entry basis, there's no problem mixing multiple entries in the same controller like in this example, where one entry is serverside and the other is clientside rendered - as long as `clientRender` matches for each entry's body and page contributions.
====

And we're done, our new _custom-flow_ Part is now ready.

{zwsp} +

=== Setup

All of this amounted to a new Part, _custom-flow_. It can be added to any Region, so just follow link:#adding_parts_to_new_content[the same setup steps] in Content Studio to add and see it.

Again, if you add more than one _custom-flow_ Part to a Region, you'll see that they are independent both in behavior and output; separated by their unique ID.


{zwsp} +
{zwsp} +




[[imports_chunks]]
== 6: Imports, chunks, config, webpack

This final example is going to be more reallife-like. We'll focus on these features:

- Using an entry from a *shared entries* folder outside of the _site/_ structure
- Letting the entry itself *import and nest its own react components*. Imports like this are just regular frontend ES6, and happen at compile time, done by webpack.
- Importing those secondary assets from a shared non-entry folder, and marking that folder so everything in it is turned into a separate bundle - a *dependency chunk*. These chunks are repeatedly-used, effectively-cached and rarely-downloaded "library assets" of shared secondary components. They're meant to take care of bigger stuff while keeping the footprint of the entry small (while still automatically compiled and tracked by react4xp).
- Our react components will need some compilation that react4xp doesn't handle: styling our react components (but it could be anything on the webpack step: asset handling, loaders etc). So we'll see how to *add custom webpack config* to the react4xp setup.

.Files involved:
[source,files]
----
site/parts/
    multi-color/
        multi-color.es6
        multi-color.xml

react4xp/
    entries/
        MultiColor.jsx
        MultiColor.scss
    shared/
        ActiveColorOval.jsx
        ActiveColorOval.scss
        Button.jsx
        Button.scss
        ColorButton.jsx
        ColorButton.scss
        shared-styles.scss

react4xp.properties
webpack.config.react4xp.js
----


As you can see, there are more moving parts than before to coordinate here, so we'll divide the code into *three sections*:

- an XP part at the core of things, fetching editorial data from XP and inserting it into a react4xp entry - as before,
- the entries and imported assets under _react4xp/_,
- and adaptations to the react4xp config, which will enable webpack handling of styles and enable the Part controller to find and use the entry and its imports the way we want.


{zwsp} +

=== The multi-color Part

Starting out with the _multi-color_ Part at the core of it all, everything in this section should be familiar by now. The *Part definition* enables two editorial configurations:

.site/parts/multi-color/multi-color.xml:
[source,xml,options="nowrap"]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<part>
    <display-name>Multi-Color</display-name>
    <description>Add your own clickable colors</description>

    <form>
        <input name="SSR" type="CheckBox">          <!--1-->
            <label>Server-side rendering</label>
            <occurrences minimum="1" maximum="1"/>
        </input>

        <input name="colors" type="TextLine">       <!--2-->
            <label>Color</label>
            <occurrences minimum="0" maximum="0"/>
        </input>
    </form>
</part>
----
<1> a checkbox for making the entry serverside or clientside rendered,
<2> and an array of colors where a user in Content Studio can add any number of HTML-compliant color tags.

As for the *Part controller*, we don't need any more than this in this example:

.site/parts/multi-color/multi-color.es6:
[source,javascript,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const component = portal.getComponent();

    const clientRender = !component.config.SSR       <!--1-->

    const colors = (component.config.colors || [])   <!--2-->
        .map( c => (c || '').trim())
        .filter(c => !!c);

    return React4xp.render(
        "MultiColor",                                <!--3-->
        { colors },
        request,
        { clientRender }
    );
};
----
<1> Taking the serverside-rendering checkbox from the Part's config, and turning it into a `clientRender` flag that's sent into the _options_ argument link:#_client_side_rendering[just like before].
<2> Creating a `colors` array of the color names from the Part's config, trimming them and removing empty ones. This is passed into the _props_ argument link:#editorial_props[like before].
<3> This one is a little bit different compared to previously. `"MultiColor"` is a link:#jsxPath[jsxPath] to an entry, but why does it look so... naked? Where does it point to? As we'll see link:#[webpack_config[later], we'll set up react4xp to look for entries below an `entryDir` in react4xp.properties: _src/main/resources/react4xp/entries/_. Since a jsxPath is relative to the closest parent `entryDir` and we'll put an entry _MultiColor.jsx_ at the root of _entries/_, the jsxPath becomes just the clean file name.



{zwsp} +

=== The Entry and its dependencies

Before we do that react4xp / webpack configuration though, let's make *the _MultiColor.jsx_ entry* and its dependencies.

This is a more complex entry than before (and the most complex part of this example): it's a *stateful* react component that not only *imports and nests secondary react components*, but also imports *styling* - both its own specific and shared general styling - and relies on webpack and react4xp to handle all the compilation and assets behind the scenes.

.src/main/resources/react4xp/entries/MultiColor.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react';

import Button from '../shared/Button';                  <!--1-->
import ColorButtons from '../shared/ColorButtons';
import ActiveColorOval from '../shared/ActiveColorOval';

import './MultiColor.scss';                             <!--2-->
import '../shared/shared-styles.scss';                  <!--3-->

class MultiColor extends React.Component {              <!--4-->
    constructor(props) {
        super(props);
        this.state = {
            selected: 0                                 <!--5-->
        };

        this.shiftUp = this.shiftUp.bind(this);         <!--6-->
        this.shiftDown = this.shiftDown.bind(this);
    }

    shiftUp() {                                         <!--7-->
        this.setState({
            selected: (this.state.selected + 1) % this.props.colors.length
        });
    };
    shiftDown() {
        this.setState({
            selected: (this.props.colors.length + this.state.selected - 1) % this.props.colors.length
        });
    };

    render() {
        const props =  this.props;
        const state = this.state;
        return props.colors.length ?                    <!--8-->
            <div className="multi-color">

                                                        <!--9-->
                <Button className="my-button" clickFunc={this.shiftDown}>Previous color</Button>
                <Button className="my-button" clickFunc={this.shiftUp}>Next color</Button>

                                                        <!--10-->
                <ActiveColorOval color={props.colors[state.selected]} />

                                                        <!--11-->
                <ColorButtons colors={props.colors}
                              selectedIndex={state.selected}
                              clickFunc={ i => {
                                  this.setState({selected: (i) % props.colors.length});
                              }}
                />

            </div> :

                                                        <!--12-->
            <p>Add some color!</p>
    }
}

                                                        <!--13-->
export default (props) => <MultiColor {...props} />;
----
<1> The entry imports some secondary react components for nesting later. These imports have nothing to do with react4xp's link:#jsxPath[jsxPath system], this is regular *ES6 importing* and will be handled by webpack at compile time. Any react component can be imported from anywhere here, including other entries. In this case we're referring to components below a different folder, _shared/_, which we will link:#webpack_config[later] mark as a *chunk directory* instead of an entry directory. _Shared/_ is not below _entries/_ but adjacent to it, so these imported react components will not be entries, just secondary react components and not reachable with `React4xp.render`. As you will see, this *folder separation* is also important for the compiled outcome: the entry, _MultiColor.jsx_, will be compiled into _assets/react4xp/MultiColor.js_, but *imported components* like this will be collected inside a common link:#chunks[dependency chunk]: _assets/react4xp/shared.<HASH>.js_. React4xp and webpack track the dependency connections between an entry and all its required chunks - so `React4xp.render` automatically generates asset-loading page contributions from the controller. The outcome: when the webpack rules are set up correctly later, *imports like this in entries rendered by react4xp are all that's needed to connect the entries to the additional assets they might need*: no manual url handling in the controller or thymeleaf views etc. Dependency chunks are also  optimized for repeated use.
<2> This applies to styling too. Here, the entry imports some specific styling of its own, from a SASS file in the _entries/_ folder. This import is webpack-centric syntax too: the SASS in _MultiColor.scss_ is compiled to the asset _assets/react4xp/Multicolor.css_, and automatically added when using this entry (of course, there's more than one way to handle styling in webpack, this is just one working example).
<3> Another SASS styling import, this time not from the same folder but from the _shared/_ folder. Just like with compiled JS chunks, all imported styling below _shared/_ will be compiled into the dependency chunk _assets/react4xp/shared.<HASH>.css_ - again automatically handled.
<4> Unlike previous examples, this is an old-school stateful react Component with class syntax. See also (13).
<5> The `selected` state attribute keeps track of which of the colors is currently selected, by index number in the `props.colors` array. In regular react fashion, each time this is changed the component is re-rendered.
<6> This makes the whole `MultiColors` class available as `this` also inside the functions `shiftUp` and `shiftDown`.
<7> `shiftUp` and `shiftDown` change the `selected` state attribute, increasing/decreasing it by 1 and wrapping around the array edges.
<8> If no colors have been added editorially, the part just displays an _Add some color!_ `<p>` (12). Otherwise, the actual active content is rendered:
<9> Two buttons, increasing and decreasing the selected color. This uses the imported `Button` component from (1) twice. Two different labels and onClick functions are mapped to them, and they are both given a `my-button` HTML class for styling.
<10> The import `ActiveColorOval` is given the currently selected color string, and displays it in an elliptic label on the page.
<11> Next, a list of buttons collected in a `ColorButtons` component. It's given the list of colors and the currently selected index (5), as well as a function that changes the selection index. All in all: click the a color's button to select it.
<12> The fallback rendering if no colors have been added (5).
<13> Remember that link:#entries[entries need to export a function]: _(props?) => react component_. Since this component is written in the class syntax (4), it needs to be wrapped like this for export.

{zwsp} +

Now, with the entry done, we can look at the *entry's styling* - a lot simpler, only the buttons' class `my-button` is targeted and styled:

.src/main/resources/react4xp/entries/MultiColor.scss:
[source,sass,options="nowrap"]
----
.my-button {
    padding: 16px 35px;
    border-radius: 5px;
    border: 2px solid black;
    font-weight: bold;
    margin: 10px 40px;
}
----

{zwsp} +

*Moving on to the _shared/_ folder*, this is where we find source files that will be compiled into common assets: dependency chunks with the _"shared"_ prefix and a content-dependent _"<HASH>"_ (reminder: this will happen because we later will mark _shared/_ as a `chunkDir` in _react4xp.properites_).

First, some *_shared-styles.scss_*, also imported by the entry _MultiColor.jsx_. This could for example serve as common, normalizing styling imported by many react components across wide parts of a site:

.src/main/resources/react4xp/shared/shared-styles.scss:
[source,sass,options="nowrap"]
----
* {
  font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;
  font-size: 15pt;
}
----

Next, _shared/_ also contains the *secondary react components* imported by  _MultiColor.jsx_. Note how each of them imports their own specific styling the same way as the entry _MultiColor.jsx_.

There's the generic *Button* component. This is used both by _MultiColor.jsx_ and the secondary component _ColorButtons.jsx_. It gets custom onClick function, HTML class, inline styling (for single-button-specific attributes) and label (`children`) from `props` (the spread-out function parameters):


.src/main/resources/react4xp/shared/Button.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react';

import './Button.scss';    <!--1-->

export default ({clickFunc, className, style, children}) =>
    <button className={className}
            type="button"
            onClick={clickFunc}
            style={style}
    >
        {children}
    </button>;
----
<1> The specific Button styling it imports is marginal - this is just a generic button, so most of the styling is left to the class it's given, or inline attributes:

.src/main/resources/react4xp/shared/Button.scss:
[source,sass,options="nowrap"]
----
button {
  cursor:pointer;
}
----

{zwsp} +

Then there's the *ActiveColorOval* component, which just displays `props.color` inside a circle/ellipse thing, filled with the same color:

.src/main/resources/react4xp/shared/ActiveColorOval.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react';

import './ActiveColorOval.scss';

export default ({color}) =>
    <div className="active-color-oval"
         style={{backgroundColor: color}}
    >
        {color}
    </div>
----

.src/main/resources/react4xp/shared/ActiveColorOval.scss:
[source,sass,options="nowrap"]
----
.active-color-oval {
  margin: 10px 40px;
  background-color: transparent;
  padding: 20px;
  border-radius: 50%;
  float: right;
  color: white;
}
----

{zwsp} +

And finally a *ColorButtons* component. It takes the list of `props.colors` (from the editorial data), and assigns each of them to a `Button` labeled with the color, each of them triggering the change-color-selection from _MultiColor.jsx_ with its own specific color index `i` in the list of colors. In addition, the HTML class name(s) of the buttons is assigned dynamically: the buttons all have a `color-button` class, and each item checks if its own array index `i` matches the current `selectedIndex`. If it does, the class `selected` is added, making that button differently styled:

.src/main/resources/react4xp/shared/ColorButtons.jsx:
[source,javascript,options="nowrap"]
----
import React from 'react';

import Button from './Button';

import './ColorButtons.scss';

export default ({colors, selectedIndex, clickFunc}) =>
    <ul className="color-list">
        {colors.map( (color, i) =>

            <li key={i} className="color">
                <Button className={`color-button${i === selectedIndex ? ' selected' : ''}`}
                        clickFunc={ ()=>clickFunc(i) }
                        style={{backgroundColor: color, borderColor: color}}
                >
                    {color}
                </Button>
            </li>

        )}
    </ul>;
----

.src/main/resources/react4xp/shared/ColorButtons.scss:
[source,sass,options="nowrap"]
----
.color {
  width: 50%;
  list-style-type: none;
  margin-bottom: 5px;
}

.color-button {
  min-width: 100%;
  padding: 6px;
  border-radius: 5px;
  border: 1px solid black;

  &:focus {
    outline: none;
  }

  &.selected {
    color: white;
    font-weight: bold;
  }

  &:not(.selected) {
    background-color: white !important;
  }
}
----


{zwsp} +

[[webpack_config]]
=== Configuring react4xp and webpack

In this section we'll adjust some settings to make the code above work.

TIP: Some of this has already been covered in more detail in the link:#entries[entries] and link:#jsxPath[jsxPath] boxes.

First, open _react4xp.properties_ in your project root and add/look up the attributes `entryDirs` and `chunkDirs`. Make sure `entries` are added as an `entryDir` and `shared` is added as a `chunkDir`.

NOTE: Both `entrydirs` and `chunkDirs` are comma-separated *lists of relative paths*. They are relative to _src/main/resource/react4xp/_, and adding paths like `foo/bar/baz` or `../../hey/ho/lets/go` is just fine.

.react4xp.properties:
[source,properties,options="nowrap"]
----
entryDirs = entries   <!--1-->

chunkDirs = shared    <!--2-->
----
<1> `entryDirs` is a list of where react4xp will look for source files to compile and serve as entries: in this case _src/main/resource/react4xp/entries_. This list is *in addition* to XP's _site/_ folder - _site/_ always acts as a sort of default, special-case entryDir: under _site/_ only .JSX files are picked up as entries, while in all other entryDirs, .ES6 and .JS are picked up as well.
<2> `chunkDirs` is a list of folders that will be turned into collection/library assets (dependency chunks): in this case _src/main/resource/react4xp/shared_. One chunk asset for each file type in each chunkDir, named after the chunkDir.

So in our example here, JSX files under _entries/_ are available to `React4xp.render` and friends, in XP controllers. Each entry becomes an asset file in itself.

And everything they import from under _shared/_ and that is compiled into JS (both react and otherwise), will be collected into the chunk `shared.<HASH>.js` - and everything under _shared/_ that's compiled into CSS (our SASS, for example) is collected into `shared.<HASH>.css`. And so on.


{zwsp} +

Next, we'll add some *custom webpack rules to handle the style imports*. First, we need to tell react4xp to use an extra webpack config file. Return to _react4xp.properties_ to add another property:

.react4xp.properties:
[source,properties,options="nowrap"]
----
overrideComponentWebpack = webpack.config.react4xp.js
----

Now we can add our own webpack rules to the react4xp asset compilation and handling:

.webpack.config.react4xp.js:
[source,javascript,linenums,options="nowrap"]
----
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = function(env, config) {                     <!--1-->

    // This makes 'npm link' symlinks in node_modules work:
    config.resolve.symlinks = true;

    // Compile .scss and friends:
    config.module.rules = [                                  <!--2-->
        ...(config.module.rules || []),
        {
            test: /\.((sa|sc|c))ss$/i,
            use: [
                MiniCssExtractPlugin.loader,
                {
                    loader: 'css-loader',
                    options: {
                        importLoaders: 1,
                        modules: { auto: true },
                    }
                },
                {
                    loader: 'sass-loader',
                    options: {
                        sassOptions: {
                            outputStyle: 'compressed',
                        },
                    },
                }
            ]
        }
    ];

    // Set up how the compiled assets are exported:
    config.plugins = [
        ...(config.plugins || []),
        new MiniCssExtractPlugin({
            filename: '[name].css',
            chunkFilename: '[id].[contenthash:9].css',
        }),
    ];

    return config;                                           <!--3-->
};
----
<1> Currently, the whole file *must export a function* where the arguments are a standard webpack `env` object, and `config` which is the existing webpack config object from react4xp.
<2> That function may *mutate (or replace!) the react4xp webpack `config` object* (on this line and later: "take any incoming `config.module.rules` and add this style-compilation-rule object"). So previously existing attributes will be overwritten by the new ones from this file.
<3> The function *must return the changed (or replaced) config object*.

And that's the last of it. We're ready to look at it running.

{zwsp} +

=== Setup and rendering

Build again and add the _multi-color_ Part in Content Studio, link:#adding_parts_to_new_content[the same way as before].

.Empty multicolor Part:
image:multicolor-add.png[title="Empty MultiColor part in Content Studio", width=720px]

{zwsp} +

Click it in edit mode to edit the Part config. Here you can choose to render the part in serverside or clientside mode, as well as enter any number of colors. As long as they are link:https://en.wikipedia.org/wiki/Web_colors[standard web colors], they will create an array of colored buttons.

.Multicolor Part with colors filled in:
image:multicolor-added.png[title="MultiColor part in Content Studio, with four colors added", width=720px]

{zwsp} +

Outside of Content Studio, in the preview, the buttons are of course active and clickable. Each button selects itself, the Previous/Next buttons cycle through them, and the little elliptic label (the ActiveColorOval) is updated with both text and color:

.Multicolor Part, active view:
image:multicolor-preview.png[,title="MultiColor part outside of Content Studio, active view after clicking the #5d0015 button", width=720px]

{zwsp} +


=== Output
Let's take a look at the rendered response from the controller and underline a few things that by now might be as you expected:

.Page source from the Multicolor Part, active view (serverside rendered not selected):
[source,html,options="nowrap"]
----
<html>
    <head>
        <title>MultColor</title>

        <!--1-->
        <link href="(...your.app.service) /react4xp/shared.9fa09c20d.css"
              rel="stylesheet"
              type="text/css"/>
        <link href="(...your.app.service) /react4xp/MultiColor.css"
              rel="stylesheet"
              type="text/css"/>
    </head>

    <body class="xp-page">
        <div id="react4xp_453f84f9-043f-4376-89fc-93855501e063">
            <div class="default-page" data-reactroot="">
                <div data-portal-region="main" class="xp-region">

                    <!--2-->
                    <div data-portal-component-type="part" id="_67815286"></div>
                </div>
            </div>
        </div>

        <!--3-->
        <script src="(...your.app.service) /react4xp/shared.27a8a0669.js"></script>
        <script src="(...your.app.service) /react4xp/externals.489d97cdf.js"></script>
        <script src="(...your.app.service) /react4xp-client/"></script>
        <script src="(...your.app.service) /react4xp/MultiColor.js"></script>

        <script defer>
            React4xp.CLIENT.render(
                React4xp['MultiColor'],
                "_67815286",
                {
                    "colors": ["Red", "Khaki", "#c0ffee", "#5d0015"],
                    "react4xpId": "_67815286"
                }
            );
        </script>
    </body>
</html>
----
<1> Firstly, the SASS files have all been compiled to .CSS assets, and stylesheet links to them are inserted into the header by `React4xp.render` (if we had used the link:#custom_flow[custom flow syntax], this would have been handled by `.renderPageContributions`). And secondly: while `MultiColor.scss` was compiled into a .CSS file by itself (because the source file is under the entryDir _entries/_), we see that all the other imported assets have been compiled into the common dependency chunk _shared.<HASH>.css_ (_not_ because they were imported by .JSX files under _shared/_ - the import location doesn't matter. But because the .SCSS source files were under _shared/_).
<2> Again, since we didn't check the "Server-side rendering" checkbox, the `clientRender` flag became true and we got a clientside rendering. So this is just the target container element, filled in by the browser on `React4xp.CLIENT.render` below. Had we checked the checkbox, this would have contained the pre-rendered MultiColor entry, of course.
<3> Among the dependencies are still the externals, the client wrapper code and the code to the compiled MultiColor entry. And in addition, there's the `shared.<HASH>.js` dependency chunk, containing the compiled code for all the ES6/JS/JSX found under the _shared/_ folder.

{zwsp} +
{zwsp} +


[[chunks]]
== Dependency chunks

To summarize and reiterate a few of the things we've looked at around dependency chunks and how to use them:

====

*A dependency chunk is a compiled asset that contains (usually a collection of multiple) components that are used at runtime*. Think of it as a library of secondary resources. Dependency chunks are served by react4xp to the client and used there. They may contain JS, or other types of code.

Entries and other chunks can import resources from chunks using *ordinary ES6 imports*, as long as the necessary webpack rules are added. Compilation rules for ES6 and JSX are included with react4xp, the rest must be custom added - see link:#imports_chunks[example 6].

{zwsp} +

.Entries and chunks - the full picture:
image:entries_and_chunks.png[link="media/entries_and_chunks.png", title="Controllers, entries and chunks visualized together. Click for larger version.", width=720px]

See also: the link:#entries_and_jsxpath[entries and jsxPath] info boxes.

{zwsp} +

In the standard react4xp setup, two chunks are likely to appear without any further setup: *externals and vendors*. That is, their names are hashed and will appear as `externals.<hash>.js` and `vendors.<hash>.js`.

- Externals usually contains react and react-dom, ensuring that the same react version is used when rendering on the client and server.
- Vendors is the chunk for anything else imported from _node_modules_.

You can also *define your own dependency chunk structure*. Additional folders (relative to _src/main/resources/react4xp/_) can be defined with `chunkDirs` in _react4xp.properties_. This will cause all source files under each chunkDir to be compiled into one common dependency chunk (or to be precise: one chunk for each codetype defined by webpack rules, e.g. separate JS and CSS chunks).

- The asset's name will be the name of the parent folder, with a content hash: <chunkName>.<hash>.<extension>.
- For example, adding `chunkDirs = foo/bar` under _react4xp.properties_, adding _hey.js_ and _baz/ho.js_ and importing stuff from _hey_ and _ho_ in an entry, will create the dependency chunk _bar.<hash>.js_ - which contains both _hey_ and _ho_.

{zwsp} +

What happens if an entry imports something from folders *not marked as chunkDirs*?

- Importing an entry into anonther entry is possible, and leaves both entries compiled and handled as regular entries.
- Imported JS (react components etc) from non-entry folders will be *compiled into the entry asset* itself. Try to avoid this, since the entries can become bloated, and code can become repeated if it's imported into more than entry. The entry assets are also less performance optimized.
- Non-JS imports (CSS etc), are compiled to separate assets under their own name, the same way as entries (but are not given a _jsxPath_, of course).

{zwsp} +

Dependency chunks never contain link:#entries[entries]; each entry is an asset file of its own. Consequently, nothing inside a dependency chunk will have a jsxPath. This is why entries are used as a separate word from react components: all entries are react components, but react components can also be secondary imports from chunks / chunkDirs. Only entries are runtime-available to react4xp.

{zwsp} +

Chunks are handy for collecting related secondary resources (that may be frequently used together in one part of a site but not others, for instance - making it possible to minimize the necessary client downloads). But most importantly, they are automatically *optimized for performance*:

- They are both cached on the server side as well as in the client - preventing repeated generation and minimizing downloads, speeding up the site.
- The hash is updated by content, for effective cache busting.
- Even if the resources in a chunk are used more than once on a page, the chunk is only downloaded once.

{zwsp} +

*Recommended usage:* chunks are made to be *fire-and-forget*. Define the chunkDir, some webpack rules if necessary, and import it from your entry (or your secondary components inside chunks) - react4xp will handle the rest. Dependencies are tracked, so `React4xp.render` (and `.renderPageContributions`) automatically adds extra client-side links to necessary chunks.

Since chunks are most optimized for repeated usage, it's best to put your heavy components and resources in chunks, and *let the entries stay slim and lightweight*.

====

{zwsp} +
{zwsp} +


== Need to go deeper?

Thats _most_ of what React4XP offers. For more technical details, some corner-case features, adaptability and more complex functionality, we will shortly release on the Enonic pages a full API overview and other in-depth documentation for the library and build setup.
