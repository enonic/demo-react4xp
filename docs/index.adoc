= Starter: Build React sites in XP
:toc: right
:imagesdir: media/

image::react4xp.svg["React4xp logo" width=256px]

This tutorial will show you how to build XP sites and apps with React rendering.

[NOTE]
====
This is _not_ a tutorial for learning React in itself, or how to get started using Enonic XP. For that, many excellent guides exist already, see for example https://reactjs.org/tutorial/tutorial.html[the official intro to React] or https://developer.enonic.com/start[the Enonic XP developer portal].

Being a little familiar with https://webpack.js.org/guides/getting-started/[webpack] doesn't hurt either.
====

{nbsp} +

== Introduction

This tutorial takes you through the basic steps of creating a React app, helping you kickstart a React4xp project of your own.

During this exercise you will:

- set up the starter and meet the React4xp library,
- learn how to use it to render a basic React component from any regular XP controller - in this case a part,
- inject editorial data into your React component,
- see how to point the controller to the React components - and where to put them in your project source,
- dig a little deeper into ways of controlling the rendering,

[NOTE]
====
The starter and this guide aims for how-to, what-is and setup of React4xp with *XP 7*. An XP6-compatible version will be released shortly. If you're using XP6 and the XP6 starter, only the React4xp installation and build commands are different from XP7. The rest of the way it's pretty identical, so *you can still use this guide for both versions.*
====

{nbsp} +
{nbsp} +

=== The React4xp library

React4xp is an XP library that:

- makes it easy to get started with rendering React from ordinary XP controllers - making JSX look like any other templating engine,
- is flexible enough to cover many more advanced use cases,
- features some tricks right out of the box to conveniently cover a couple of common needs - such as isomorphic client- or serverside rendering and hydration, build flow and compilation, automated asset serving with optimization, and more
- aims to be modular and tweakable, making it possible to pop the hood, pick it apart and set things up your own way. Godspeed!

https://github.com/enonic/lib-react4xp/blob/master/README.md#installing-the-library[The React4XP documentation is right here].

{nbsp} +
{nbsp} +
{nbsp} +

== Get started

=== Create a starter project

To setup a project locally, run the following command:

  enonic project create -r starter-react4xp

Remember to create a *new XP sandbox* when completing the project wizard.

NOTE: *Don't have the Enonic CLI?* Visit the https://developer.enonic.com/start[Getting started guide] to install it.

{nbsp} +

=== Build and Deploy

To build and deploy the app, run this command from your shell:

  enonic project deploy

Accept starting the sandbox.

[NOTE]
====
To verify that your app started successfully, you should find an entry similar to this in the sandbox log:

  2019-04-09 13:40:40,765 INFO ... Application [<name.of.your.app>] installed successfully
====


{nbsp} +
{nbsp} +
{nbsp} +

== Project structure

If you're used to working with an https://developer.enonic.com/guides/my-first-webapp[ordinary] XP project with https://developer.enonic.com/templates/webpack[webpack], the structure will look familiar - the biggest news is the folder `react4xp/` under `resources/`.

TIP: You don't need to know the following structure by heart to get started. *Just put your JSX source files under `react4xp/_entries/` or under `site/`, and you're ready to build and run.*

Your project folder should look something like this:

.Selected files:
[source,files]
----
build.gradle <--1-->
settings.gradle <--1-->
package.json <--2-->
build/ <--3-->
src/
  main/
    resources/
      assets/ <!--4-->
      react4xp/ <!--5-->
        _entries/ <!--6-->
          REPLACE_ME.jsx <!--7-->
      site/
        parts/ <!--8-->
        pages/ <!--8-->
        REPLACE_ME.jsx <!--7-->
      webapp/ <!--9-->
----

<1> The gradle files are used by the build system. The starter includes some setup here: the *lib-react4xp* library and some building tasks,
<2> `package.json` sets up NPM import of some packages that React4XP and the build process need,
<3> `build/` will contain output files from the build process. The files from the React4XP part of the build will all be put into the subfolder `build/resources/main/assets/react4xp`. These are used after the build, by both client- and server-side runtime processes,
<4> ..just note that your React4XP source files should normally NOT be put in `assets/react4xp`! The `assets/` folder is just used in the regular XP way for other, general assets: non-React4xp JS, CSS, icons, etc.
<5> *React4XP will instead look for your JS and JSX files under the `react4xp/` folder* (they are kept apart from other XP source files because they are treated differently in the build). You can make subfolders under here, they will be compiled into "sub-libraries" - reusable _chunks_ that contain code that your ReactXP entries can import (but are not themselves accessable by React4XP). More on this below.
<6> The *one special magic folder* that will not be turned into chunks, is `react4xp/\_entries/`. This is here you put your *entries* - the React component source files that can be accessed by React4xp in the XP controllers. We'll get back to this below.
<7> Two `REPLACE_ME.jsx` files: placeholders for webpack. Remove each of these when you've added one or more React source file below `react4xp/_entries/` and `site/`.
<8> Below the `site/parts/` and `site/pages/` subfolders is as always where you put your XP parts and pages. Now with React4xp, *you can also put JSX entries together with your parts and pages*. This is the easiest way to use a React4XP entry from a part/page controller.
<9> Outside of the scope of this tutorial but worth mentioning: the `webapp/` folder containing the root webapp controller. React4XP supplies services that allow static HTML pages to refer to and request compiled entries.


{nbsp} +
{nbsp} +
{nbsp} +

== Examples

These examples are incremental: the later, advanced examples are clearer if you've seen the previous ones.

TIP: They can be downloaded along with everything needed to run, by checking out the https://github.com/enonic/starter-react4xp/tree/examples[examples branch of starter-react4xp]

{nbsp} +

=== 1: Hello World: server-side rendering by default

Let's make a simple XP part that contains a react component: `01-minimal-example`

.Files involved:
[source,files]
----
site/parts/01-minimal-example/
  01-minimal-example.xml
  01-minimal-example.jsx
  01-minimal-example.es6
----

Add a *part definition*. It doen't need anything special, just XP boilerplate:

.01-minimal-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>01 - Minimal Example</display-name>
  <description>Simple example with server-side rendering by default</description>
  <form />
</part>
----

*Now for the React component itself - the entry:*

.01-minimal-example.jsx
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) => <p>Hello {props.greetee}!</p>;
----

[NOTE]
====
*_Entries_ in React4XP are the React components that can be accessed by React4XP*. They are just any standard JSX file, as long as it:

- default-exports a function that returns a React element, and
- is placed under the folder `/react4xp/_entries` or like in this example: in a part or page folder under `site/`.
====

The returned function can take an optional `props` object parameter. Our entry will receive a `greetee` prop and greet it with a magnificent _Hello_.


Now moving on, make the *part controller* that uses React4XP to render the entry:

.01-minimal-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const component = portal.getComponent();
    const props = { greetee: "world" };

    return React4xp.render(component, props, request);
};
----

It basically just imports `React4xp` and uses the `.render` function, similar to how you might be familiar with from Thymeleaf or other XP template engines:

- The first argument is a reference to the template (just like the first view reference in the Thymeleaf renderer). In our case the template is the React4XP entry, and React4XP uses the `component` data (for the part itself) to locate the JSX file in the part's own folder (expecting the same file name as the part).
- The second argument, `props`, is similar to the `model` argument in the Thymeleaf renderer. No big surprise: it's passed to the entry's `props`. Here is the _world_ we're about to greet.
- The third `request` argument is necessary for a fully activated React rendering. You _can_ leave it out to render the entry as pure HTML if you like JSX as a pure templating language, but it won't be activated (https://reactjs.org/docs/react-dom.html#hydrate[hydrated]) in the browser.

*The returned response object* from `.render` is sent straight from the controller to the client, and contains:

- a `body` field with a server-side rendering (in static HTML) of the entry with the entered props,
- and some `pageContributions` that make the client activate the React entry (containing the necessary asset links and React hydration commands).

[NOTE]
====
An important difference from Thymeleaf's renderer is that `React4XP.render` generates _a full response object_ that can be directly returned from the controller, instead of just HTML that you need to wrap in a `body` field in the controller's response object.
====

{nbsp} +
{nbsp} +

*That's it. This part is ready to display in XP!* Let's add it to a page in Content Studio and render it:*

- Run `enonic project deploy` from your shell, start the sandbox and direct your browser to `localhost:8080/admin`.
- Log in to XP and open Content Studio.
- Create some content (e.g. a site with the Default Page controller included with the starter, or a https://market.enonic.com/vendors/enonic/landingpage-lib[a landing page]). Anything with a Region will do.
- Insert a new part into the region, and select the `01-minimal-example` part you just made.
- Enter the preview to view the content outside of Content Studio. You should now see:

[.thumb]
image::hello-world.png["Glorious greeting of the very existence itself!" width=492px]

{nbsp} +
{nbsp} +

Curious about what happened here? *View the page source code in the browser* to see what `.render` created - something like this (the number-tagged lines):
[source,html,options="nowrap"]
----
<!DOCTYPE html>
<html>
  <head>(...)</head>

  <body>

    <main data-portal-region="main" class="xp-region">
      <div (...) id="parts_01-minimal-example__main_0">
      	<p data-reactroot="">Hello <!-- -->world<!-- -->!</p> <!--1-->
      </div>
    </main>

    <script src="(...) /react4xp/externals.88e80cab5.js"></script>  <!--2-->
    <script src="(...) /react4xp-client/"></script> <!--3-->
    <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--4-->
    <script defer> <!--5-->
      React4xp.CLIENT.hydrate(
        React4xp['site/parts/01-minimal-example/01-minimal-example'],
        "parts_01-minimal-example__main_0",
        { "greetee": "world", "react4xpId": "parts_01-minimal-example__main_0" }
      );
    </script>

   </body>
</html>
----

<1> A container element with an ID, and inside it: an HTML representation of the JSX entry, pre-rendered by React4XP on the server with the initial props.
<2> A standard `externals` chunk (the exact path may vary with local setups, so it's truncated to `(...)`. The same goes for the cache-busting hash in the filename). This contains React and ReactDOM, built-in with React4XP.
<3> The React4xp client wrapper, which enables the hydration command in point #5, among other things. A global client-side object is created, `React4xp`, which will contain all things React4xp in runtime. The client wrapper is `React4xp.CLIENT`.
<4> The entry itself - the compiled version of `01-minimal-example.jsx`.
<5> Calling `React4xp.CLIENT.hydrate`, the hydration of the entry along with a path pointer to the entry (we'll get back to this below, as the concept of _jsxPath_), the ID of the container element the entry is rendered into, and the props.

[NOTE]
====
We only added the `greetee` prop in the controller. The other one, `react4xpId`, is the unique ID of the component, same as the container element ID. It's always added as a prop for each entry, conveniently helping to separate multiple instances of the same component (e.g. allowing them to share a common redux store without meddling with each other's state).
====
{nbsp} +
{nbsp} +

=== 2: Client-side rendering, params, target body, XP props, jsxPath

In this example we'll create another part, similar to the link:#_1_hello_world[first example], but with these variations:

- Add optional parameters to the rendering,
  * ...with a `clientRender` flag, turning the entire output into client-side React rendering.
- We'll render the react entry into a target container element that already exists in an HTML body,
  * ...which comes from a Thymeleaf template _before_ the entry is rendered into it.
- We'll use an entry that's not in the part's own folder - we'll actually reuse to the same JSX entry as in the first example,
  * ...and we'll insert editorial data from Content Studio into the props.

.Files involved:
[source,files]
----
site/parts/
  01-minimal-example/
    01-minimal-example.jsx
  02-clientrender-example/
    02-clientrender-example.xml
    02-clientrender-example.html
    02-clientrender-example.es6
----

Still a pretty unremarkable *part definition*. Only now there's a `greetee` TextLine input field ready for some editorial text from Content Studio.

.02-clientrender-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
	<display-name>02 - ClientRender Example</display-name>
    <description>Client-side rendered react component</description>
	<form>
        <input name="greetee" type="TextLine">
            <label>Who or what should we greet?</label>
            <occurrences minimum="1" maximum="1"/>
            <default>world</default>
        </input>
    </form>
</part>
----

*The thymeleaf template* shows that a target container element can be anywhere in an HTML body - same as in vanilla react - as long as we point to it with a unique element ID. Here: `"second-example-container"`.

.02-clientrender-example.html
[source,html,linenums,options="nowrap"]
----
<div class="serverside-example">
    <h2>Server-side rendering example</h2>
    <p>Server-side rendered and hydrated, inserted below:</p>
    <div id="second-example-container"></div>
    <p>(And we're done)</p>
</div>
----

TIP: We've hardcoded the ID here and in the controller for clarity. The best practice however, would be to pass it to thymeleaf through the model.

Moving on to *the part controller*, where the React4xp stuff happens:

.02-clientrender-example.es6:
[source,javascript,linenums,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

const view = resolve('02-clientrender-example.html'); <!--1-->

exports.get = function(request) {
    const component = portal.getComponent();

    const preExistingBody = thymeleaf.render(view, {}); <!--1-->

    const props = {
        greetee: component.config.greetee <!--2-->
    };

    const jsxPath = 'site/parts/01-minimal-example/01-minimal-example'; <!--3-->

    const params = {
        <!--4-->
        body: preExistingBody,
        id: 'second-example-container',
        clientRender: true,
    };

    return React4xp.render(jsxPath, props, request, params);
----

What's happening here?

<1>  The HTML with the target container element is rendered,

<2> We get the `greetee` value from XP and insert in into the props,

<3> Here an important concept is introduced: *A _jsxPath_ is the name of an entry in React4xp*. We used the `component` object to refer to the entry in the first example, which is easy but _only works if the entry is in the same folder and has the same name_. Here we want the entry from a different part's folder: the same entry we used before. These strings are _names_, not paths relative to the controller (so avoid `../` etc). You can read more about entries here, but *the rules of thumb are*:
  * If an entry file is a JSX file under `src/main/resources/site`, the jsxPath is the file path relative to `src/main/resources/` - unix-style and without file extension.
  * An entry can also be located under `src/main/resources/react4xp/_entries`, and then the jsxPath will be relative to that folder instead.
  * If you're ever unsure: all the available jsxPaths are stored in `build/resources/main/assets/react4xp/entries.json`. This file is generated by webpack during build (and shouldn't be deleted or edited).

<4> We're adding some *parameters* as a fourth argument object to `.render`:
  * `body` is the HTML body we're inserting the React entry into,
  * `id` is setting the ID, and targeting that container element in `body`,
  * `clientRender`: if this is truthy, you get old-school client-side React rendering. `.render` doesn't render the entry on the server-side, but leaves the target container unchanged and instead makes some page contributions that makes the browser build the entry into the target container.
  * It's also possible to add a `pageContributions` field, for adding pre-existing page contributions to the ones that `.render` generates.

[NOTE]
====
In the first example, we didn't pass an `id` or a `body` to `.render`, but it still worked. *They are both optional*, React4XP generates what's missing: If no `body` is found, React4xp will generate an empty HTML with a matching element ID. If there's no `id` found either, a random number is used - or data from `component` if you used that in the entry argument. If there's a `body` but it doesn't have any elements with an ID matching the `id` parameter, an empty target container element is added at the end of `body`.
====


{nbsp} +
{nbsp} +

*Okay, enough - time to run the example!*

- The new part is ready. Add it to some content in Content Studio the same way you did in link:#_1_hello_world[the previous example].
- Change the part's `greetee` field: edit the content, click and mark the "Client-side rendering example" part, and edit the "Who or what should we greet?" field on the right-side config panel. When you save it, the preview should update.

[.thumb]
image::editing-clientside.png["" width=1037px]

If we open a Preview tab and dig into *the output page source*, it's similar to the previous example:
[source,html,options="nowrap"]
----
<body>
  <main data-portal-region="main" class="xp-region">

    <div class="serverside-example">
      <h2>Client-side rendering example</h2>
      <p>Skips server-side rendering, and instead sets up client-side react to render the entry into the container below:</p>
      <div id="serverside-example-container"></div> <!--1-->
      <p>(And we're done).</p>
    </div>

  </main>

  <script src="(...) /react4xp/externals.88e80cab5.js" ></script>
  <script src="(...) /react4xp-client/" ></script>
  <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--2-->
  <script defer> <!--3-->
    React4xp.CLIENT.render(
        React4xp['site/parts/01-minimal-example/01-minimal-example'],
        "second-example-container" ,
        {"greetee":"from the client side","react4xpId":"second-example-container"}
    );
  </script>
</body>
----

Most notable differences from the first example:

<1> The target container is now initially empty, there was no rendered HTML from the server.
<2> The imported entry is still the same as in the previous example. This is the compiled version of the JSX component we pointed to with `jsxPath` in the controller.
<3> Instead of `.hydrate`, we're calling `.render`. Our react component is rendered and inserted into the `"serverside-example-container"` element _by the browser_. `React4xp.CLIENT.render` has the same signature as `React4xp.CLIENT.hydrate`: `(entryJsxPath, targetElementId, props)`.


{nbsp} +
{nbsp} +

=== 3: React4xp objects: alternative syntax, more manual control. The _entries folder.

In this example we won't use `.render`. Instead, we'll look at a more direct syntax that gives you better control and opportunities for logic steps when you handle the entry.

We'll construct *a data-holding React4xp object* from an entry, manipulate it a little, and use its built-in methods to render the `body` and the `pageContributions` separately.

Other features demonstrated:

- The target container ID is inserted into `body` by Thymeleaf, which gets it from the data-holding object,,
- Using an entry outside of XP's `/site/` structure, in the base directory `/react4xp/_entries`,
- Making some raw XP page contributions before rendering, with a script with inserted editorial data. Then passing that `pageContributions` object through `.renderPageContributions`, adding it to the React4XP page contributions.

.Files involved:
[source,files]
----
react4xp/_entries/
  ColorThing.jsx
site/parts:
  /03-customflow-example/
    03-customflow-example.xml
    03-customflow-example.html
    03-customflow-example.es6
----

*The part definition* now defines some other editorial data: `color`.

.03-customflow-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>03 - CustomFlow Example</display-name>
  <description>AKA. The Color Thing</description>
  <form>
    <input name="color" type="TextLine">
      <label>What's the color of the thing?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>red</default>
    </input>
  </form>
</part>
----

*The react component* is inline-styled with the color it gets from the `props`:

.ColorThing.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) =>
  <div style={{border: `1px dotted ${props.color}`,margin:"5px",padding:"5px" }}>
    <h2>The {props.color} thing</h2>
    <p style={{color: props.color}}>Hey, I'm pretty {props.color}!</p>
  </div>;
----

*The Thymeleaf view* receives the ID of the target container element from Thymeleaf:

.03-customflow-example.html
[source,html,linenums,options="nowrap"]
----
<div>
    <p>Here comes the thing:</p>
    <div data-th-id="${targetId}"></div>
</div>
----

Finally, *the controller*:

.03-customflow-example.es6:
[source,javascript,linenums,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

const view = resolve('03-customflow-example.html');

exports.get = function(request) {
    const component = portal.getComponent();

    const reactObj = new React4xp('ColorThing'); <!--1-->

    reactObj
        .setProps({ color: component.config.color })
        .uniqueId(); <!--2-->

    const model = {
        targetId: reactObj.react4xpId <!--3-->
    };
    const preRenderedBody = thymeleaf.render(view, model);

    const preExistingPageContributions = {
        bodyEnd: `<script>
        	console.log('Okay, rendered the ${reactObj.props.color} thing.');
        		</script>`
    }; <!--3-->

    return { <!--4-->

        body: reactObj.renderBody({
            body: preRenderedBody, <!--5-->
        }),

        pageContributions: (request.mode === 'live' || request.mode === 'preview') ? <!--6-->
            reactObj.renderPageContributions({ <!--7-->
                pageContributions: preExistingPageContributions
            }) :
            undefined
    }
};


----

*Some explanations:*

<1> Constructing the data-holding React4XP object `reactObj`. The constructor takes *one mandatory argument*: an entry reference. Just like the first argument in `.render`, the entry reference can be a jsxPath OR an XP component object. Here it's a jsxPath. So why is `ColorThing`, and _only_ that, the jsxPath to `ColorThing.jsx`? Because the JSX file is at the root level of the React4XP _entries base folder_: `src/main/resources/react4xp/_entries`.

<2> The React4XP object has setter methods that return the object itself, so you can set any optional attributes with a chained builder pattern like in the example, or separately. The uniqueId() method forces the ID of the object and the target container element to be unique. If an object doesn't have an ID, this will be called by default when rendering (so we could have just skipped it here). The order of the setter methods doesn't matter. This example is equivalent to:

	reactObj.setProps({color: component.config.color});
	reactObj.uniqueId();

<3> We can read attributes from `reactObj` before the rendering. At this point, the ID (`react4xpId`) and `props` are set in it. We read them out and injecting them into the thymeleaf model and into some random page contributions.

<4> Here, `body` and `pageContributions` are rendered separately (`renderBody` and `renderPageContributions`). Remember that this is different from `.render` which does everything in one go.

<5> The Thymeleaf-rendered `body` is given to `.renderBody`, which will insert react into that HTML. Again, the `body` parameter is optional - if we don't submit it `.renderBody` will just generate a target container for you, with a matching ID.

<6> The other difference from `.render`: _there's no automatic selection of rendering mode here_. If we want to *avoid active client-side JS running in Content Studio's _edit_ and _inline_ modes*, we now need to do it manually: detect the viewing mode from the `request` object and just skip the pageContributions.

<7> We render the necessary page contributions for activating the entry, and pass `preExistingPageContributions` through `.renderPageContributions` - just adding it to the rendered page contributions. The `pageContributions` parameter is optional.

[NOTE]
====
Just like the `.render` method in examples 01 and 02, we can control `.renderBody` and `.renderPageContributions` with the `clientRender` parameter. In this example, we called them both without it (so `body` is rendered on the server-side into the HTML, and `.hydrate` is called on the body in the client, instead of `.render`).
The `clientRender` parameter *should match between the two rendering functions* for a React4XP object: if we add it to `.renderBody` (and it's true/truthy), we should add it to `.renderPageContributions` too.
====


{nbsp} +

*Okay, let's take a look:*
Like before, open Enonic XP Content Studio, add the new part to some content, select and edit it and change the Color of the Thing, for example to "blue".

Save, it should look something like this:

[.thumb]
image::the-blue-thing2.png["" width=1068px]

If we open it in Preview and look at the browser console, we also see that the little `console.log` script from the controller has picked up the `color` prop from the React4XP object:

[.thumb]
image::the-blue-thing.png["" width=1068px]

*The output page source* should similar to this (and similar to what `.render` generated earlier):

[source,html,options="nowrap"]
----
<body>
    <main data-portal-region="main" class="xp-region">

        <div data-portal-component-type="part">
            <p>Here comes the thing:</p>
            <div></div>
            <div id="_99689402">
                <div style="border:1px dotted blue;margin:5px;padding:5px" data-reactroot="">
                    <h2>The <!-- -->blue<!-- --> thing</h2>
                    <p style="color:blue">Hey, I'm pretty <!-- -->blue<!-- --> !</p>
                </div>
            </div>
        </div>

    </main>
    <script src="/admin/site/preview/default/draft/example03/_/service/com.enonic.app.react4xp/react4xp/externals.88e80cab5.js"></script>
    <script src="/admin/site/preview/default/draft/example03/_/service/com.enonic.app.react4xp/react4xp-client/"></script>

    <script>console.log('Okay, rendered the blue thing.');</script>

    <script src="/admin/site/preview/default/draft/example03/_/service/com.enonic.app.react4xp/react4xp/ColorThing.js"></script>
    <script defer>React4xp.CLIENT.hydrate(React4xp['ColorThing'], "_99689402", {
        "color": "blue",
        "react4xpId": "_99689402"
    });</script>
</body>
----

Note the random but matching ID (_uniqueId_) of the target container and the `react4xpId` of the `React4xp.CLIENT.hydrate` call.

{nbsp} +
{nbsp} +

=== 4: A part with multiple react components, chaining, nesting, hydration

A more complex example, where we'll look at using *multiple react components in a single part* - including reusing multiple instances of _the same_ react component and making them unique within the part:

- rendering a stateful component, more powerful than before,
- ...which is serverside-rendered as a passive string and then activated in the client with `.hydrate`,
- chaining (passing the body and pageContributions through multiple react4xp data objects),
- nesting shared, non-entry react components in an entry,
- how `import`-ing non-entry code results in a predictable chunk structure,

.Files involved:
[source,files]
----
react4xp/
  myChunk/
    BuilderClicker.jsx <!--1-->
  _entries/
    mySubfolder/
      BuilderClickerEntry.jsx <!--2-->
site/parts:
  /04-chaining-example/
    04-chaining-example.jsx <!--3-->
    04-chaining-example.xml <!--4-->
    04-chaining-example.html <!--5-->
    04-chaining-example.es6 <!--6-->
----

{nbsp} +
*1.* `BuilderClicker` is a shared react component that will be imported by `BuilderClickerEntry` and put inside the chunk `myChunk.<hash>.js` - because it's below the `myChunk` subfolder instead of `_entries`. *As a non-entry, it will not get a jsxPath*, so it will be better optimized but must be imported by an entry to be used in React4xp. It's also a *stateful and active* react component: the props are stored and output after one another in a `<h3>` element, and can be changed: each of them are repeated/doubled when clicked in the client (so repeated clicks will build a lot of text, hence the name):

.BuilderClicker.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

class BuilderClicker extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            first: props.first,
            second: props.second,
        }
    };

    // Doubles the 'first' or 'second' string in state, depending on the key.
    makeMore = (key) => {
        this.setState({[key]: this.state[key] + " " + this.state[key]});
    };

    render() {
        return <div className="builderclicker">
            <h3>
                <span onClick={() => this.makeMore('first')}
                      style={{cursor: "pointer"}}
                      className="first">{this.state.first}
                </span> <span onClick={() => this.makeMore('second')}
                      style={{cursor: "pointer"}}
                      className="second">{this.state.second}</span>
            </h3>
        </div>;
    }
};

export default (props) => <BuilderClicker {...props} />;
----

{nbsp} +
*2.* `BuilderClickerEntry` is a simple entry component (since it's below `_entries`), just a container for the shared `BuilderClicker`. We will use it directly in our part, with the jsxPath `mySubfolder/BuilderClickerEntry`. But it will also be imported by a different entry, the part's own JSX. This makes no structural difference: entries can be imported by other entries, and are still entries:

.BuilderClickerEntry.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

import BuilderClicker from '../../myChunk/BuilderClicker';

export default (props) => <div className="builderclicker-entry">
		<BuilderClicker {...props} />
	</div>;
----

{nbsp} +
*3.* `04-chaining-example.jsx` is the part's internal react entry. It serves no other purpose than to demonstrate that an entry can import and nest another entry in the standard JS/react way, should you ever need to:

.04-chaining-example.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

import BuilderClickerEntry from '../../../react4xp/_entries/mySubfolder/BuilderClickerEntry';

export default (props) => <BuilderClickerEntry {...props} />;
----


{nbsp} +
*4.* `04-chaining-example.xml`, the *part definition*, doesn't do anything this time:

.04-chaining-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
	<display-name>04 - Chaining Example</display-name>
    <description>Multiple react components, chaining, nesting, hydration</description>
	<form />
</part>
----

{nbsp} +
*5.* `04-chaining-example.html`, the *part view*, is just some description, two target containers (with `id` that will be referred in the controller) and a horizontal line:

.04-chaining-example.html:
[source,html,linenums,options="nowrap"]
----
<div class="chaining-example">
    <h1>04 - Chaining Example</h1>
    <p>These two target containers existed in the HTML:</p>
    <div data-th-id="a-target-container"></div>
    <div data-th-id="another-target-container"></div>

    <hr style="display:block; margin:20px; width:100%; height:1px; border:1px dotted #aaa;"/>
    <p>The rest of the containers don't exist before rendering, but are inserted at the end:</p>
</div>
----

{nbsp} +
*6.* `04-chaining-example.es6`, the *part controller*:

.04-chaining-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const thymeleaf = require('/lib/thymeleaf');
const React4xp = require('/lib/enonic/react4xp');

const view = resolve("04-chaining-example.html");

exports.get = function(request) {

    // Renders BuilderClickerEntry, which nests BuilderClicker,
    // into the "a-target-container" element:
    const firstComp = new React4xp('mySubfolder/BuilderClickerEntry')
        .setId("a-target-container")
        .setProps({
            first: "Click",
            second: "ME!"
        });

    // Uses the component to point to and render the part-local
    // 04-chaining-example.jsx, which nests BuilderClickerEntry
    // and BuilderClicker with it, into the "another-target-container" element:
    const secondComp = new React4xp(portal.getComponent())
        .setId("another-target-container")
        .setProps({
            first: "No click ME!",
            second: "I do the exact same thing only better!"
        });

    // Creates a body starting point from the local HTML view:
    let body = thymeleaf.render(view, {});

    // Chaining: passes the body through the two components' server-side
    // rendering methods, which add passive HTML inside the two target
    // containers in it:
    body = firstComp.renderSSRIntoContainer(body);
    body = secondComp.renderSSRIntoContainer(body);

    // Chaining: creates the necessary page contributions for hydration
    // for the first component, and passes them through the second one. The
    // second turn only appends what's necessary, so that shared components
    // and dependency chunks etc aren't loaded twice:
    let pageContributions = firstComp.renderHydrationPageContributions();
    pageContributions = secondComp.renderHydrationPageContributions(pageContributions);


    // ------------------------------
    // A horizontal separator comes here in the view: a new section,
    // demonstrating a way to repeat the same entry multiple times in a part.
    // All the target containers here are generated and added to the body,
    // since the components' IDs don't match anything in the body.
    // ------------------------------


    // Creates 4 components with different props: "first repeated ID",
    // "second repeated ID", etc. Note that ALL of them are given the same ID.
    // That means they are all rendered into the same target container,
    // so only the last one will be visibly rendered:
    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {
        const notUniqueComp = new React4xp('site/parts/01-minimal-example/01-minimal-example')
            .setId('this-is-not-unique')
            .setProps({ greetee: `${cardinalNum} repeated ID`});

        body = notUniqueComp.renderTargetContainer(body);
        pageContributions = notUniqueComp.renderClientPageContributions(pageContributions);
    });

    // Same as above, but with a crucial difference: adding `.uniqueId()` to the ID
    // makes React4xp add a random-number postfix to the ID. This causes each component
    // to have a different ID, so 4 container elements are added to body instead of one
    // - and all four become visible.
    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {
        const uniqueComp = new React4xp('site/parts/01-minimal-example/01-minimal-example')
            .setId('this-id-is-unique').uniqueId()
            .setProps({ greetee: `${cardinalNum} unique ID`});

        body = uniqueComp.renderTargetContainer(body);
        pageContributions = uniqueComp.renderClientPageContributions(pageContributions);
    });

    // Returning the body/pageContribution response from the part.
    return {
        body,
        pageContributions,
    };
};
----

NOTE: In this example (line 57-78), we're making a new React4xp object for each rendering. An object can in principle be re-rendered with different props, *but rendering a body or pageContribution will lock the ID* of the object. I.e., a re-rendering of the same React4xp object will always target the same container element! Trying to change the ID will throw an error.

{nbsp} +

*Screenshot of the rendered output:*

[.thumb]
image::chaining.png["You clicked? I am but a humble screenshot." width=1036px]

Comparing this screenshot (or better, run the example and check out the actual output) with the page source below, there are a few things worth noting:

- in the actual output, the _"click me"_ components are active and clickable: clicking the first or second half of each of them doubles the clicked text, as defined in the `BuilderClicker`. This activation happened in the `.hydrate` steps (lines 58 and 64 below).
- the clicks are isolated to the component that was actually clicked: even though they are technically the same inner component `BuilderClicker` (by source), they each have their own state so when one is clicked the other one doesn't react. This is not because `BuilderClicker` is nested differently in them, but because their ID's are different,
- as predicted, since the ID was the same in all 4 renderings (line 60 in `04-chaining-example.es6`), only one container with `id="this-is-not-unique"` was added to the body (line 41 below),
- and although the four React4xp objects each add a separate `React4xp.CLIENT.render` call (lines 71, 76, 81, 86), they all target the same container, so only the last one is remains in the end,
- and since `"this-id-is-unique"` had a different postfix appended each time, all the 4 renderings created a different container (lines 42-45), and each of those are visibly rendered.
- React4xp automatically traced the dependency to `myChunk.<hash>.js` and added this import to the page contributions (line 51), because `BuilderClicker` lives there. As long as the `site` and `react4xp` folders are used for entries and dependency chunks as described, imports like this will always be handled automatically,
- and although several of the generated assets are called more than once, the page contributions are trimmed so each of them are only loaded to the client once (lines 49-56).


.Page source:
[source,html,linenums,options="nowrap"]
----
<!DOCTYPE html>
<html>
  <head></head>

  <body>

    <main data-portal-region="main" class="xp-region">
      <div data-portal-component-type="part" class="chaining-example">

        <h1>04 - Chaining Example</h1>
        <p>These two target containers existed in the HTML:</p>

        <div id="a-target-container">
          <div class="builderclicker-entry" data-reactroot="">
            <div class="builderclicker">
              <h3>
                <span style="cursor:pointer" class="first">Click</span>
                <span style="cursor:pointer" class="second">ME!</span>
              </h3>
            </div>
          </div>
        </div>

        <div id="another-target-container">
          <div class="builderclicker-entry" data-reactroot="">
            <div class="builderclicker">
              <h3>
                <span style="cursor:pointer" class="first">No click ME!</span>
                <span style="cursor:pointer" class="second">I do the exact same thing only better!</span>
              </h3>
            </div>
          </div>
        </div>

        <hr style="display:block; margin:20px; width:100%; height:1px; border:1px dotted #aaa;"></hr>

        <p>The rest of the containers didn't exist before rendering, and so, are inserted at the end:</p>
        <div id="this-is-not-unique"></div>
        <div id="this-id-is-unique_90354192"></div>
        <div id="this-id-is-unique_43124046"></div>
        <div id="this-id-is-unique_87401825"></div>
        <div id="this-id-is-unique_63865684"></div>
      </div>
    </main>

    <script src="(...) /react4xp/externals.88e80cab5.js"></script>
    <script src="(...) /react4xp-client/"></script>
    <script src="(...) /react4xp/myChunk.059c6f899.js"></script>
    <script src="(...) /react4xp/mySubfolder/BuilderClickerEntry.js"></script>
    <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script>
    <script src="(...) /react4xp/site/parts/04-chaining-example/04-chaining-example.js"></script>

    <script defer>React4xp.CLIENT.hydrate(React4xp['mySubfolder/BuilderClickerEntry'], "a-target-container", {
      "first": "Click",
      "second": "ME!",
      "react4xpId": "a-target-container"
    });</script>
    <script defer>React4xp.CLIENT.hydrate(React4xp['site/parts/04-chaining-example/04-chaining-example'], "another-target-container", {
      "first": "No click ME!",
      "second": "I do the exact same thing only better!",
      "react4xpId": "another-target-container"
    });</script>

    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "first repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "second repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "third repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "fourth repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>

    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_90354192", {
      "greetee": "first unique ID",
      "react4xpId": "this-id-is-unique_90354192"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_43124046", {
      "greetee": "second unique ID",
      "react4xpId": "this-id-is-unique_43124046"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_87401825", {
      "greetee": "third unique ID",
      "react4xpId": "this-id-is-unique_87401825"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_63865684", {
      "greetee": "fourth unique ID",
      "react4xpId": "this-id-is-unique_63865684"
    });</script>
  </body>
</html>
----



{nbsp} +
{nbsp} +

=== 5: Webapp
The last demonstration is the services `/react4xp/`, `/react4xp-client/`, `/react4xp-dependencies/` and `/react4xp-externals/`. These enable you to take advantage of React4xp components and features directly from a client-side script from scratch (except for server-side rendering, which obviously isn't available).

In the example below, we'll use XP's https://developer.enonic.com/guides/my-first-webapp[webapp] functionality with a thymeleaf template, enabling us to use `portal.serviceUrl` to get the fully prefixed URL to the services. But as long as long as you know the prefix service URL to an XP server running React4xp, you could hard code the urls if you wanted and use this feature from a completely standalone HTML.

`React4xp.CLIENT.renderWithDependencies` abstracts and simplifies all the necessary steps in rendering multiple entries into multiple target containers, including tracing and fetching entries and dependency chunks once. It needs:

- React, ReactDOM and the React4xp client wrapper must be fetched (line 5-15 below),
- The prefix service URL must be set, as a global `SERVICE_URL_ROOT` variable (line 34).

.pure.html:
[source,html,linenums,options="nowrap"]
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- OPTION 1: You can get React and ReactDOM from CDN like this... -->
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>

    <!-- OPTION 2:
      ...but React and ReactDOM are also available as a chunk from this service:
      <script data-th-src="${portal.serviceUrl({'_service=react4xp-externals'})}"></script>
    -->

    <!-- The client wrapper is needed either way: -->
    <script data-th-src="${portal.serviceUrl({'_service=react4xp-client'})}"></script>
  </head>

  <body>
    <h1>Standalone HTML</h1>

    <!-- Target containers -->
    <div id="color_thing"></div>
    <div id="clickable_thing"></div>

    <!-- Sets a global variable SERVICE_URL_ROOT.
    This is the root URL prefix to the services used
    by React4xp.CLIENT.renderWithDependencies.
    Can be set anywhere as long as it's before
    renderWithDependencies is called: -->
    <script data-th-text="|var SERVICE_URL_ROOT=`${portal.serviceUrl({'_service='})}`;|"></script>

    <!-- Actual rendering call: -->
    <script>
        React4xp.CLIENT.renderWithDependencies(

          // First parameter: an object where the keys are jsxPaths
          // (which can still be used more than once as long as the IDs
          // are unique), and the values are objects with
          // `targetId` and `props` parameters:
          {
            ColorThing: {
              targetId: 'color_thing',
              props: { color: "purple"}
            },

            'site/parts/04-chaining-example/04-chaining-example': {
              targetId: 'clickable_thing',
              props: { first: "Come On!", second: "Click Me Already!" },
            },
          },

          // Demo callback in an optional second parameter:
          function() {
              console.log("This callback is inserted and called after rendering.");
          }
        );
    </script>
  </body>
</html>
----

{nbsp} +
{nbsp} +

== API

More details can be found at https://github.com/enonic/lib-react4xp#readme[the main library docs] and the source code in that repo.

{nbsp} +

=== Controller functions

.Import:
[source,javascript,options="nowrap"]
----
const React4xp = require('/lib/enonic/react4xp');

// Equivalent: import React4xp from '/lib/enonic/react4xp';
----

{nbsp} +

.Shorthand rendering:
[source,javascript,options="nowrap"]
----
React4xp.render(request, params); <!--1-->

React4xp.renderSafe(request, params);  <!--2-->
----

<1> `React4xp.render`: *All-in-one best-practice renderer.* Renders server-side if it can, adds hydration logic for the client-side. Renders dynamic/client-side react in XP preview and live mode, and static/server-side in edit mode (XP content studio). On problems, falls back to `renderSafe`.

<2> `React4xp.renderSafe`: *Client-side and fallback renderer.* More thorough fallback and failure reporting, and avoids server-side rendering - except in edit mode, where client-side rendering is the bigger hazard.

*Both have the same signatures and returns:*

  * `request` _(object, mandatory)_ XP request object.
  * `params` _(object, mandatory)_ MUST include `jsxPath` or `component`. And if not `component`, either an `id` OR a non-falsy `uniqueId` parameter is needed. Target component file must exist. If `component` AND one of `jsxPath` or `id` are included, those data from `component` are overridden. *Subfields* in `params`:
  ** `component` _(object)_ XP component object (used to extrapolate component part and target container ID). This is sufficient if the JSX entry file is in the same folder and has the same name, and the react component doesn't need to be rendered into a particular pre-existing HTML container element.
  ** `jsxPath` _(string)_ path to react component entry, see available paths in `build/resources/main/assets/react4xp/entries.json` after building the parent project with react4xp-build-components. These are *names*, not relative paths. So jsxPath can't contain '..', '//', '/./' or start with '.' or '/'.
  ** `id` _(string, optional)_ sets the target container element id (overrides the extrapolated id if component was set). If this matches an ID in an input body, the react component will be rendered there. If not, a container with this ID will be added.
  ** `uniqueId` _(boolean|string, optional)_ If set, ensures that the ID is unique. If id is set (previous param), a random integer will be postfixed to it. If uniqueId is a string, this is the prefix before the random postfix. If the id param is used in addition to a uniqueId string, uniqueId takes presedence and overrides id.
  ** `props` _(object, optional)_ react props sent in to the component
  ** `body` _(string, optional)_ Existing HTML body, for example rendered from thymeleaf. If it already has a matching-ID target container, body passes through unchanged (use this option and the setId method to control where in the body the react component should be inserted). If it doesn't have a matching container, a matching <div> will be inserted at the end of the body, inside the root element. If body is missing, a pure-target-container body is generated and returned.
  ** `pageContributions` _(object, optional)_ Pre-existing pageContributions. New page contributions for rendering this component will be added to any pre-existing ones.

They *return* a response object that can be directly returned from an XP controller, with the fields `body` and `pageContributions`: `body` will contain a target container element for the react component. `pageContributions` will contain scripts referred by URL for running the component client-side and the component's dependencies, as well as an inline trigger script for starting the react frontend rendering into the target container. Duplicates in `pageContributions` will be removed, to avoid running identical scripts twice.


{nbsp} +

.Data object construction:
[source,javascript,options="nowrap"]
----
const comp = new React4xp(component|jsxPath);
----

The constructor has a mandatory parameter, ONE of the following two. This follows the same logic as the `component` and `jsxPath` subfields in `params` in the shorthand rendering methods above:

  * EITHER `component` _(object)_ Current-XP-component data; the output of `portal.getComponent()`. This will point to a local (same-name, same-folder as the component) react file. Derives and sets the component's `jsxPath` AND its `id` (`react4xpId`) so they don't need to be set.
  * OR `jsxPath` _(string)_ Pointer to any component. Sets the component's `jsxPath` but not the `id`.

*Returns* the constructed data-holding object (`comp`) where these fields are readable:

  * `.jsxPath` _(string)_ The jsxPath of the target react entry. The entry must exist.
  * `.props` _(object)_ Component props, if set (see below),
  * `.react4xpId` _(string)_ Component and target-container ID, if set (see below). If not set, the rendering methods will thow an error.

{nbsp} +

.Attribute setters in the data object:
[source,javascript,options="nowrap"]
----
comp.setProps(props); <!--1-->
comp.setJsxPath(jsxPath); <!--2-->
comp.setId(id); <!--3-->
comp.uniqueId(); <!--4-->

// Sequence doesn't matter (except for setId, which can overwrite a previous uniqueId).
// And a builder pattern is supported, so this would be equivalent:
//
//   comp.setProps(props)
//       .setJsxPath(jsxPath)
//       .setId(id)
//       .uniqueId();
----

<1> `setProps(props)`: `props` _(object)_ is any object serializable by `JSON.stringify`. Overwrites previous props. Props will be fed to the entry component. Even if not set explicitly, the props received by the entry component will always contain the ID, as the field `react4xpId`.
<2> `setJsxPath(jsxPath)`: `jsxPath` _(string)_ points to an entry component that must exist, jsxPath must be valid. Overwrites previous value.
<3> `setId(id)`: `id` _(string)_ Identifies the react4xp component (`comp`) and points to a target container in the DOM to receive the react rendering. Preferrably a unique element `id` in the DOM. Corresponds to `comp.react4xpId` and `props.react4xpId`.
<4> `uniqueId()`: enforces a unique element and component ID, by appending a random-number postfix. If an ID hasn't been set, it will become the random-number postfix.

All of the above *return* the object itself, enabling the builder pattern.


{nbsp} +

.Data object body HTML rendering:
[source,javascript,options="nowrap"]
----
const htmlContent = comp.renderComponentString(overrideProps); <!--1-->

const newBody = comp.renderTargetContainer(existingBody, htmlContent); <!--2-->

const newBody = comp.renderSSRIntoContainer(existingBody); <!--3-->

// Using renderSSRIntoContainer is equivalent to:
// const newBody = comp.renderTargetContainer(existingBody, comp.renderComponentString());

----

<1> `comp.renderComponentString(overrideProps)`: (server-side) renders and returns a *simple HTML string representation of the data object*, without a container or any further `body` interaction, based on the `props` currently set in the data object, or `overrideProps` _(object, optional)_ if they are set.

<2> `renderTargetContainer`: *Primary client-side body renderer*. Parameters:

  * `existingBody` _(string, optional)_ String containing HTML, and only that. If empty, a target container (with an `id` matching the ID of the data object `comp`) will be returned. If there is an HTML string but a matching-ID container is not found, a target container is added _at the end of the root element of the HTML_, i.e. just before the final closing tag. If there's a string _with_ a matching ID, nothing is changed.
  * `htmlContent` _(string, optional)_ HTML string. If empty or missing: no effect. If included, this will be injected inside the matching-ID container (that's guaranteed by the logic in the previous parameter), replacing any content that was already there. Note that in client-side rendering, `htmlContent` is usually left empty, leaving it to the client to inject some rendered content into the container.

  * *Returns* a valid HTML string, ready to be returned from a controller as the `body` field in the response - or be sent as the `existingBody` into a rendering method of a different React4xp object (see the chaining example).

<3> `renderSSRIntoContainer`: *Primary server-side body renderer*. First renders an HTML representation of the data object `comp` based on its current `props`, then injects that HTML into a (new or existing) matching-id target container in `existingBody`.  Parameters:
  * `existingBody` _(string, optional)_ Same as `existingBody` for `.renderTargetContainer`: string containing HTML, and only that. If empty, a target container (with an `id` matching the ID of the data object `comp`) will be returned. If there is an HTML string but a matching-ID container is not found, a target container is added _at the end of the root element of the HTML_, i.e. just before the final closing tag. If there's a string _with_ a matching ID, nothing is changed.

{nbsp} +

.Data object pageContributions rendering:
[source,javascript,options="nowrap"]
----
const newPageContributions = comp.renderClientPageContributions(existingPageContributions); <!--1-->

const newPageContributions = comp.renderHydrationPageContributions(existingPageContributions); <!--2-->
----

<1> `renderClientPageContributions(existingPageContributions)`: *Primary client-side pageContributions renderer*. Returns a new page contributions object, with `existingPageContributions` _(object, optional)_ added to it, and the needed pageContributions to get the client to fetch the dependencies of `comp` and render it into the matching-ID container (provided by one of the body HTML rendering methods above). This includes the entry of `comp`, all the chunks of its imported dependencies, the client-side wrapper and the _externals_, meaning client-side runnable React and ReactDOM code, the same used for the client-side rendering. Trims the pageContributions before returning them, preventing excessive loading on the client side.

<2> `renderHydrationPageContributions(existingPageContributions)`: *Primary server-side pageContributions renderer*. Identical to `.renderClientPageContributions` above, but expects that the matching-ID container already has the HTML of `comp` injected into it from the server - and then has the client trigger a https://reactjs.org/docs/react-dom.html#hydrate[react hydration] of it: activating the previously-passive HTML representation and turning it into a fully active react component.

{nbsp} +

=== Services
The four included React4xp services are exposed to the client and are central to how it fetches the assets, dependencies and the client wrapper itself. Half of what the auto-generated pageContributions are doing, uses the services. However, the services are directly usable as well. They are documented https://github.com/enonic/lib-react4xp#the-services[in the main library docs].

{nbsp} +

=== Client-side wrapper
Downloadable from the `/react4xp-client` service, is client-runnable code that wraps a few handy functions, used by the autogenerated pageContributions, but usable manually as well.

It creates a `React4xp` global object in the browser, which will contain all things React4xp. It exposes three methods under the `React4xp.CLIENT` attribute:

.Client-side wrapper functions:
[source,javascript,options="nowrap"]
----
React4xp.CLIENT.render(Component, targetId, props); // corresponds to https://reactjs.org/docs/react-dom.html#render

React4xp.CLIENT.hydrate(Component, targetId, props); // corresponds to https://reactjs.org/docs/react-dom.html#hydrate

React4xp.CLIENT.renderWithDependencies(componentsTargetsAndProps, callback, serviceUrlRoot);
----

The first two methods are 'pure' renderers. This means that in addition to the client wrapper, you need to supply and run scripts for React and ReactDOM (which are bundled in the React4xp _externals_) - and scripts for the entries as well as all their chunks, before calling `render` or `hydrate`.

However, you can also use React4xp components in a standalone html page, having only React/ReactDOM (or React4xp externals) and this client loaded in the browser: use `renderWithDependencies` as below.

{nbsp} +

==== Using `render` and `hydrate`
They both have a `(Component, targetId [, props])` signature:

  * `Component`: _(React4xp entry or any ReactDOM renderable, mandatory)_ If it's a function, the wrapper will try to turn it into a ReactDOM component by running `Component(props)`. When loading React4xp entries, they are exposed in the client as functions as part of the `React4xp` object: `React4xp[jsxPath] = (props) => Component`. A fallback has been added so that if an entry component has been compiled into a `.default` sub-attribute, the client can access the component both with and without the `default` field: if `React4xp.CLIENT.render(React4xp.myComponent.default, ...)` is strictly correct, then `React4xp.CLIENT.render(React4xp.MyComponent, ...)` will also work.
  * `targetId` _(string, mandatory)_ The unique ID of an HTML container element, into which the component will be rendered. Obviously, this must exist in the DOM when running.
  * `props`: _(object, optional)_ Top-level props that will be sent into the component. React4xp relies on serialization of this object, so _functions can't be passed in this way!_

{nbsp} +

==== Using `renderWithDependencies`
This wraps a whole chain of necessary steps: when the client has the wrapper available, you know where to contact the services (the prefix: their common URL before the service names), you have some React4xp components you want to render and know their jsxPaths and props, then `renderWithDependencies` will take care of all the gritty details needed for a client-side render, in a single call for multiple React4xp components:

  - contact the React4xp services,
  - determine what the entries' chunk dependencies are,
  - download and run those in parallel,
  - then download and run the entry scripts,
  - then run `render` on each of the entries,
  - all the time preventing duplicate downloads.

Parameters:

  * `componentsTargetsAndProps` _(object, mandatory)_ Object where each entry is similar to the `Component, targetId, [, props]` signature mentioned above: the *keys*  are jsxPath strings of React4xp entries. The *values* are objects that have a mandatory `targetId` string and an optional `props` object.
  * `callback` _(function, optional)_ This function is run after running `render`,
  * `serviceUrlRoot` _(string, optional)_ Root of the URL to the `/react4xp` and `/react4xp-dependencies` link:#_services[services]. For example, if they have the URLs `/_/service/my.app/react4xp/` and `/_/service/my.app/react4xp-dependencies/`, then `serviceRootUrl` should be `/_/service/my.app` (without a trailing slash). This is _sort of optional_: you can skip it if you define a constant `SERVICE_URL_ROOT` in global namespace before running  `renderWithDependencies` (see link:#_5_webapp[the Webapp example]). If you don't, it's a mandatory argument.


{nbsp} +
{nbsp} +

== Gotchas

=== Imports and chunks
When building your react components, *you can import JS/ES6 code as usual*: nested react components, your own secondary code, other frameworks, libraries, whatever... Imported code can be compiled into separate asset chunks from the entries that use them, for https://webpack.js.org/guides/code-splitting/[code splitting].

This chunking is easy to control: *put the imported sources in chunk-named subfolders below the `react4xp/` folder* (outside of `_entries`). Done this way, React4xp will handle:

 - optimized building and serving of the entries and chunks,
 - client-and-server-side caching with cache busting,
 - keep track of exactly which secondary chunks are needed for displaying which component entries,
 - and add the necessary client-side script requests/imports along with the response.

https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[More about entries and chunks in the core library documentation].

TIP: Chunks are more optimized than entries. Ideally, keep the served entries slim and leave the heavy lifting to chunks.

{nbsp} +

=== Rendering in different modes
Usually, it's recommended to use server-side rendering and hydration if you can. However, when using XP, it's recommended to avoid running client-side scripts in Content Studio's edit mode, as far as possible. This can be detected with `request.mode` in a controller, you can use this to control the pageContributions behavior in edit mode.

The link:#_controller_functions[shorthand rendering functions] will handle this automatically.

{nbsp} +

=== Adding/adjusting React4xp to an existing project
If you have an existing XP project you want to integrate React4xp into, the easiest way is probably to look at https://github.com/enonic/starter-react4xp/blob/master/build.gradle[build.gradle] and https://github.com/enonic/starter-react4xp/blob/master/package.json[package.json] from the starter project, and weave them into your own to add the support.

Things to keep in mind:

* `react4xp-build-components`, `react4xp-buildconstants` and `react4xp-runtime-externals` in package.json, and the line `include 'com.enonic.lib:lib-react4xp:0.3.3'` in build.gradle are all important.
* So is the React4xp configuration: lines 41-86 in build.gradle.
** The basic structure of a React4xp project, as described in this guide, is actually meant to be flexible and adjustable. See the https://www.npmjs.com/package/react4xp-buildconstants[react4xp-buildconstants docs] and tweak `REACT4XP_OVERRIDES` in build.gradle.
* The gradle task `webpack_react4xp` in build.gradle triggers a webpack build, targeting the react components and only those: `react4xp-build-components`. Here, webpack runs webpack.config.js files that are fetched from the NPM packages. This task can probably be added as-is (depending on your react build requirements).
** However, if you need a different or adjusted webpack setup, you can run `npm install` and copy the contents from `node_modules/react4xp-build-components/webpack.config.js` into a webpack config of your own, adjust that, and refer to that in build.gradle instead of the react4xp-build-components one.
** Important: if you tweak `webpack_react4xp`, make sure that this task doesn't target and transpile the "normal" XP functional source files, that'll mess things up.
* The gradle task `babelXP` in build.gradle is a pretty bare-bone setup for _only_ transpiling the "normal" XP functional files.
** Important: if you tweak `babelXP`, make sure that this task doesn't target and transpile the React4xp source files. That'll mess things up for sure.
