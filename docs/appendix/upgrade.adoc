= Recommended upgrade
:toc: right
:imagesdir: media/
:sourcedir: ../src/main/resources/
:snippet: ../../code-samples/code-snippets/

== Step by step

This describes upgrading to the full feature set of react4xp 6 including migrating pages and layouts to react.

. Create an app using the link:../setup#create-starter[starter^] and give it a new name.
. <<migrating-parts, Migrate>> each react component to the new app.
. Migrate your <<migrate-page, page>> and <<migrate-layout, layout>> to react components
. link:./legacy#build-deploy[Deploy^] the application on your existing site.

You will now have one application with your schemas, and one containing your frontend.
If you prefer having a single application, follow these steps:

. Move the cms schemas and other files you want to keep to the new application.
. Rename it to the same name as your old application.
. Make a production build and link:./legacy#build-deploy[Deploy^] it.
. The old application can now be discarded.

[[migrating-parts]]
== Migrating parts

Now letâ€™s go a little bit deeper and use the example component as a part along with our new components.
To do this we need to do the following:

. Make an xml file for it so XP knows that it exists, here we can also give it a good description.
+
.src/main/resources/site/parts/example/example.xml
[source,xml]
----
include::{snippet}appendix/upgrade/example.xml[]
----

. Move the example component to the `parts/example` folder and update as follows.
+
.src/main/resources/react4xp/components/parts/example/example.tsx
[source,TypeScript]
----
include::{snippet}appendix/upgrade/example.tsx[]
----
+
Notice how the Example component receives `ComponentProps<PartData>` type props.
This is going to be true for any other component as well, except that `PartData`, specifying type of the component field, will be `LayoutData` for layouts, or `PageData` for pages:
+
[source,TypeScript]
----
interface ComponentProps<T extends ComponentData = ComponentData> {
    meta: MetaData;                         // <1>
    component: T;                           // <2>
    data?: Record<string, unknown>;         // <3>
    common?: Record<string, unknown>;       // <4>
}
----

<1> Runtime metadata, such as the current content path, id and type as well as request mode.
<2> Enonic XP component data that contains type, descriptor and some extra data based on the type (i.e. regions for layouts and pages).
<3> Component data fetched by the associated data processor, if any.
<4> Common data fetched by the common processor, if any.
+
. Now, instead of fetching in get(), create a processor that returns its data and React4xp will forward it to your view along with some additional data like meta and component.
+
.src/main/resources/react4xp/components/parts/example/exampleProcessor.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/exampleProcessor.ts[]
----

. Add it to the componentRegistry and dataFetcher with the same descriptor as in previous task.
+
.src/main/resources/react4xp/componentRegistry.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/componentRegistry.tsx[]
----
+
.src/main/resources/react4xp/dataFetcher.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/dataFetcher.ts[]
----

[[page-layout]]
[[migrate-page]]
== Pages

Your current page part might look something like this:

.src/main/resources/site/pages/default/default.tsx
[source,typeScript]
----
include::{snippet}appendix/upgrade/pages/pagev5/default.tsx[]
----

with a controller like this:

.src/main/resources/site/pages/default/default.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev5/default.ts[]
----

And an xml like this:

.src/main/resources/site/pages/default/default.xml

[source,xml]
----
include::{snippet}appendix/upgrade/pages/pagev5/default.xml[]
----

This is how we migrate it to a react4xp v6 component:

First let's handle the controller which becomes a processor, the most important prop to pass from the processor used to be the regionsData.
We can still get regions from component and return it, but this is not necessary anymore!

IMPORTANT: Component gets passed to the view automatically now, so you don't have to define a processor function if it's only regions you want to access.

.src/main/resources/react4xp/components/page/PageProcessor.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/PageProcessor.ts[]
----

Next we need to change out the part `default.tsx` with a component `Page.tsx`, which is very similar except that we pass `component` to the `Regions` react component, because it contains regions now.

.src/main/resources/react4xp/components/page/Page.tsx
[source,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/Page.tsx[]
----

In this example there is also a css module that is used to style the page.

.src/main/resources/react4xp/components/page/Page.module.css
[source,css]
----
include::{snippet}appendix/upgrade/pages/pagev6/Page.module.css[]
----

For XP to see it we need to keep the xml file, but we will change the name to `Page.xml` and add a description to it.
This way we can call on it using a descriptor in the component registry and data fetcher.

.src/main/resources/site/pages/Page/Page.xml
[source,xml]
----
include::{snippet}appendix/upgrade/pages/pagev6/Page.xml[]
----

Let's add it to componentRegistry and dataFetcher, this is done in the same way as we did with the part.

.src/main/resources/react4xp/componentRegistry.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/componentRegistry.tsx[]
----

.src/main/resources/react4xp/dataFetcher.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/dataFetcher.ts[]
----

Now we have a fully functional page component that is using the new regions and component registry.

[[migrate-layout]]
== Layouts

Lastly we need to migrate the layout, this is done in a similar way to the page.

Your current layout part might look something like this:

.src/main/resources/site/layouts/twoColumns/twoColumns.tsx
[source,typeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv5/twoColumns.tsx[]
----

with a controller like this:

.src/main/resources/site/layouts/twoColumns/twoColumns.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv5/twoColumns.ts[]
----

And an xml like this:

.src/main/resources/site/layouts/twoColumns/twoColumns.xml
[source,xml]
----
include::{snippet}appendix/upgrade/layouts/layoutv5/twoColumns.xml[]
----

Similar to the page, we need to implement a processor, and a component.

.src/main/resources/react4xp/components/layouts/TwoColumnProcessor.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumnProcessor.ts[]
----

The Layout component is depending on regions like the page, but let's use `Region` built-in component this time to render every region manually.
We need to pass list of components as data to each `Region` component:

.src/main/resources/react4xp/components/layouts/TwoColumn.tsx
[source,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumn.tsx[]
----

NOTE: Notice how we used data fetcher result stored in `data` field to access the `tags` property.

.src/main/resources/components/layouts/twoColumn.css
[source,css]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumn.module.css[]
----

We need to add the layout to the component registry and data fetcher, this is done in the same way as we did with the part and page.

.src/main/resources/react4xp/componentRegistry.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/componentRegistry.tsx[]
----

.src/main/resources/react4xp/dataFetcher.ts
[source,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/dataFetcher.ts[]
----

And finally we need to update the xml file to match the descriptor, this is done in the same way as the page.

.src/main/resources/site/layouts/TwoColumn/TwoColumn.xml
[source,xml]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumns.xml[]
----

Now we have a fully functional layout component that is using the new regions and component registry.

And just like that we have not only upgraded the old component, but also made it compatible with the new ones!
