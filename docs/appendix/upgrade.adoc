= Upgrading to v6
:toc: right
:imagesdir: media/
:sourcedir: ../src/main/resources/
:snippet: ../../code-samples/code-snippets/

== Background

This section describes the steps to upgrade from React4XP v5 go v6.

There are significant changes between these versions, but you should be able to reuse most of the code that fetches data, as well we your React templates.

== Changes

The most significant changes between these versions are:

=== Single React app

In v6, each page only has a single React entry/application, vs one entry/app per CMS part in the previous version

=== Pages and layouts must be implemented with React

In v5, pages and parts could not be implemented as TSX, because React did not support nested apps/entries.

=== Detached front-end

v5 was based on XP's traditional site engine, where rendering is bundled together with each CMS component.

React4XP severs this tie, and takes full control over the rendering, via a controller mapping.
This means you may implement the front-end/rendering code separately from the CMS model definition - even via a separate XP application than where your model is defined.

You may still add the front-end code in the same application as your model, at your own discretion.

IMPORTANT: You may still combine React4XP apps with other XP apps on the same site.
For instance apps that add services, or contribute scripts or tags to the response.

=== Component registry

TODO: Move React4XP follows a traditional MVC approach, where data is first collected into a model (in the form of props), and then passed to the view (React template)

To facilitate this, you register server-side controllers that fetches relevant content for each component

On the view side of things, each CMS component is implemented as a React component, and added to a component registry.

== Complete upgrade

This describes upgrading to the full feature set of react4xp 6 including migrating pages and layouts to react.

. Create an app using the link:../setup.adoc#create-starter[starter^] and give it a new name.
. <<migrating-parts, Migrate>> each react component to the new app.
. Migrate your <<migrate-page, page>> and <<migrate-layout, layout>> to react components
. <<build-deploy, Deploy>> the application on your existing site.

You will now have one application with your schemas, and one containing your frontend.
If you prefer having a single application, follow these steps:

. Move the cms schemas and other files you want to keep to the new application.
. Rename it to the same name as your old application.
. Make a production <<build-deploy, build and deploy>> it.
. The old application can now be discarded.

== Partial upgrade

Version 6 is still compatible with how components are rendered in version 5(each part is a separate react app/entry).

As such, you may upgrade your existing react4xp application with minimal changes to the code.

This means you will upgrade to newer versions of dependencies, without changing how your components work.

Follow these steps:

* Set your app xp version 7.15 or newer
+
.gradle.properties
[source,properties]
----
xpVersion = 7.15.0
----

* Upgrade package.json

** Use latest React4XP types
+
[source,json]
----
"@enonic-types/lib-react4xp": "^6.0.0-B7",
----

** Use latest React4XP runtime library
+
[source,json]
----
"@enonic/react4xp":       "^6.0.0-B2",
----

** Add global Enonic types (includes core transitively)
+
[source,json]
----
"@enonic-types/global":   "^7.15.0-A2",
----

  NOTE: this brings in `@enonic-types/core`:
  [source]
  ----
  ├─┬ @enonic-types/global@7.15.1
  │ └── @enonic-types/core@7.15.1
  ----

** Add React component library
+
[source,json]
----
"@enonic/react-components": "^6.0.0-B4",
----

** Add small utility deps
+
[source,json]
----
"clsx":             "^2.1.1",     // lightweight className helper
"core-js":          "^3.39.0",    // standard ES polyfills
----

** Add CSS-Modules typing & plugin
+
[source,json]
----
"@types/css-modules":           "^1",
"typescript-plugin-css-modules": "^5",
----

** Remove obsolete CSS extractor
+
[source,json]
----
// delete this line:
"mini-css-extract-plugin": "^2",
----

** Consolidate TypeScript checks Replace the old `verify:*` scripts with the new `check:*` suite:
+
[source,json]
----
"scripts": {
  // remove these:
  "verify:types":                 "concurrently -r npm:verify:types:*",
  "verify:types:guillotineRequest":"npx tsc --noEmit -p tsconfig.guillotineRequest.json",
  "verify:types:react4xp":         "npx tsc --noEmit -p tsconfig.react4xp.json",
  "verify:types:xp":               "npx tsc --noEmit -p tsconfig.xp.nashorn.json",

  // add these in their place:
  "check":                        "concurrently -c auto -g --timings npm:check:types:*",
  "check:types:node":             "npx tsc --noEmit -p tsconfig.node.json",
  "check:types:react4xp":         "npx tsc --noEmit -p tsconfig.react4xp.json",
  "check:types:xp":               "npx tsc --noEmit -p tsconfig.xp.nashorn.json"
}
----

* Verify folder structure
+
[source]
----
src/main/resources/
├─ react4xp/
│  ├─ components/
│  │  ├─ common/
│  │  │  ├ Footer.module.css
│  │  │  └ Footer.tsx
│  │  ├ content/
│  │  ├ hello/
│  │  ├ layouts/
│  │  ├ macro/
│  │  ├ page/
│  │  └ parts/
│  ├─ globalStyles.css
│  ├─ entries/
│  │  └ App.tsx
│  ├─ public/
│  └─ utils/
│     ├ componentRegistry.tsx
│     └ dataFetcher.ts
├─ site/
│  ├ app.ts
│  ├ component.ts
│  └ site.xml
├─ static/
└─ types/
├ AppProps.ts
└ HelloProps.ts
----

This layout ensures XP can discover your React4XP assets (under react4xp/), site controllers (under site/), static files, and shared TS types.

* Upgrade Build.gradle

** Add schema, assets to your dependencies and update lib-react4xp
+
[source,groovy]
----
    include "com.enonic.xp:lib-schema:${xpVersion}"
    include 'com.enonic.lib:lib-asset:1.0.1'
    include 'com.enonic.lib:lib-react4xp:6.0.0-SNAPSHOT'
----

** Inject npm-based type-checks
+
[source,groovy]
----
tasks.register('npmCheck', NpmTask) {
dependsOn npmInstall
args        = ['run','check']
environment = ['FORCE_COLOR':'true']
}
check.dependsOn npmCheck
----

** Enhance React4XP build task with NODE_ENV logic
+
[source,groovy]
----
tasks.register('react4xp', NpmTask) {
    def envMode = project.hasProperty( 'env' ) ? ( project.property( 'env' ) == 'prod' ? 'production' : 'development' ) : 'production'
    args = [
        'run', 'build:react4xp'
    ]
    dependsOn( npmInstall )
    description 'Compile react4xp resources'
    environment = [

        ...
        'NODE_ENV': envMode
    ]

    ...
    println "Environment set to: $envMode"
----

** Pass `-Penv=dev` flag in the dev task
+
[source,groovy]
----
tasks.register('dev', Exec) {
    if (System.getProperty('os.name').toLowerCase().contains('windows')) {
        commandLine 'gradlew.bat', 'deploy', '-Penv=dev', '-t'
    } else {
        commandLine './gradlew', 'deploy', '-Penv=dev', '-t'
    }
}
----


* Upgrade webpack.config.react4xp.js

** Remove old CSS-extract plugin import and pull in Rspack core
+
Old:
+
[source,js]
----
  // const MiniCssExtractPlugin = require('mini-css-extract-plugin');
  const rspack = require('@rspack/core');
----

** Swap out the loader reference in your SCSS rule
+
[source,js]
----
// MiniCssExtractPlugin.loader,
rspack.CssExtractRspackPlugin.loader,
----

** Update your CSS-loader options to disable ES-module output
+
[source,js]
----
{
loader: 'css-loader',
options: {
importLoaders: 1,
modules: { auto: true },
esModule: false
}
}
----
+
NOTE: `esModule: false` makes the loader emit CommonJS rather than ES-module exports.


** Add a font-asset rule for WOFF/TTF/etc.
+
[source,js]
----
config.module.rules = [

...

{
test: /\.(woff|woff2|eot|ttf|otf)$/i,
type: 'asset/resource'
},
]
----

** Replace the plugin instantiation with Rspack’s CSS extractor
+
[source,js]
----
	config.plugins = [
		...(config.plugins || []),
		new rspack.CssExtractRspackPlugin({
			chunkFilename: '[id].[contenthash:9].css',
			filename: '[name].[contenthash:9].css',
		})
	]
----

* Upgrade to new types

** V6 uses @enonic/types-core so you need to replace the old js-utils Request with the new one.

** Replace "Enonic.Xp.Http.Request" from '@enonic/js-utils/types/Request' with “Request” from @enonic/types-core.

[[build-deploy]]
* Make production build and deploy
+
[source,shell]
----
enonic project build
----
+
[source,shell]
----
enonic project deploy
----
+
You can also run the project in development mode, which will watch for changes and automatically deploy them to the sandbox:
+
[source,shell]
----
enonic dev
----
+
[source,shell]
----
enonic project dev
----


== Migrating parts

=== Partial migration

In react4xp v5 the example controller looks like this:

.src/main/resources/site/parts/example/example.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/example.ts[]
----

V6 uses @enonic/types-core so you need to replace the old js-utils Request with the new one.

* Replace "Enonic.Xp.Http.Request" from '@enonic/js-utils/types/Request' with “Request” from @enonic/types-core.

This is how the upgraded component looks like:
.src/main/resources/site/parts/example/example.ts

[code,TypeScript]
----
include::{snippet}appendix/upgrade/upgradedExample.ts[]
----

So far in this tutorial we have used componentRegistry to render and dataFetcher to invoke the processor for all components.

Since our old component does not have any processor and is rendered outside componentRegistry we need to exclude it so it becomes available for XP.
We do this by updating site.xml:

.src/main/resources/site/site.xml
[code,xml]
----
include::{snippet}appendix/upgrade/site.xml[]
----

Now we can use the v5 component with react4xp v6, we just need to make sure the url contains `/r4xp5`

[[migrating-parts]]
=== Complete migration

Now let’s go a little bit deeper and use the example component as a part along with our new components.
To do this we need to do the following:

. Make an xml file for it so XP knows that it exists, here we can also give it a good description.
+
.src/main/resources/site/parts/example/example.xml
[code,xml]
----
include::{snippet}appendix/upgrade/example.xml[]
----

. Move the example component to the parts folder, where we update it by wrapping it in a `Part` tag instead of `div`.
Then we add extraProps to it, this is important because react4xp v6 uses this to add necessary props to the parts component so it is possible to view and edit it within the page editor.
+
.src/main/resources/react4xp/components/parts/example/example.tsx
[code,TypeScript]
----
include::{snippet}appendix/upgrade/example.tsx[]
----

. Instead of fetching in get(), create a processor that returns its props—React4xp will forward them (plus its own metadata) into <Part> via extraProps.
+
.src/main/resources/react4xp/components/parts/example/exampleProcessor.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/exampleProcessor.ts[]
----

. Add it to the componentRegistry and dataFetcher with the same descriptor as in previous task.
+
.src/main/resources/react4xp/componentRegistry.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/componentRegistry.tsx[]
----
+
.src/main/resources/react4xp/dataFetcher.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/dataFetcher.ts[]
----

== Migrating pages and layouts

Unlike parts, pages and layouts can not be partially migrated in react4xp v6 because layouts and pages are dependent on component registry to render child components.

This means that we need to completely migrate the page and layout.

[[migrate-page]]
=== Pages

Your current page part might look something like this:

.src/main/resources/site/pages/default/default.tsx
[code,typeScript]
----
include::{snippet}appendix/upgrade/pages/pagev5/default.tsx[]
----

with a controller like this:
.src/main/resources/site/pages/default/default.ts

[code,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev5/default.ts[]
----

And an xml like this:
.src/main/resources/site/pages/default/default.xml

[code,xml]
----
include::{snippet}appendix/upgrade/pages/pagev5/default.xml[]
----

This is how we migrate it to a react4xp v6 component:

First let's handle the controller which becomes a processor, the most important prop to pass from the processor is the regionsData.
Notice how we change `regionsData` to `regions`, this is because the new Regions React component is expecting it along with componentRegistry.

.src/main/resources/react4xp/components/page/PageProcessor.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/PageProcessor.ts[]
----

Next we need to change out the part `default.tsx` with a component `page.tsx`, which is very similar except that we pass `regions` to the `Regions` react component.

.src/main/resources/react4xp/components/page/Page.tsx
[code,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/Page.tsx[]
----

For XP to see it we need to keep the xml file, but we will change the name to `Page.xml` and add a description to it.
This way we can call on it using a descriptor in the component registry and data fetcher.

.src/main/resources/site/pages/Page/Page.xml
[code,xml]
----
include::{snippet}appendix/upgrade/pages/pagev6/Page.xml[]
----

Let's add it to componentRegistry and dataFetcher, this is done in the same way as we did with the part.
.src/main/resources/react4xp/componentRegistry.ts

[code,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/componentRegistry.tsx[]
----
+
.src/main/resources/react4xp/dataFetcher.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/pages/pagev6/dataFetcher.ts[]
----

Now we have a fully functional page component that is using the new regions and component registry.

[[migrate-layout]]
=== Layouts

Lastly we need to migrate the layout, this is done in a similar way to the page.

Your current layout part might look something like this:
.src/main/resources/site/layouts/twoColumns/twoColumns.tsx

[code,typeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv5/twoColumns.tsx[]
----

with a controller like this:
.src/main/resources/site/layouts/twoColumns/twoColumns.ts

[code,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv5/twoColumns.ts[]
----

And an xml like this:
.src/main/resources/site/layouts/twoColumns/twoColumns.xml

[code,xml]
----
include::{snippet}appendix/upgrade/layouts/layoutv5/twoColumns.xml[]
----

Similar to the page, we need to implement a processor, and a component.

.src/main/resources/react4xp/components/layouts/TwoColumnProcessor.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumnProcessor.ts[]
----

The Layout component is depending on the `Regions` like the page, so we need to pass the `regions` prop to it.

.src/main/resources/react4xp/components/layouts/TwoColumn.tsx
[code,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumn.tsx[]
----

We are keeping one more prop for layout, we use this `tags: 'section'` to target the layout with our css module.

.src/main/resources/components/layouts/twoColumn.css
[code,css]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumn.module.css[]
----

We need to add the layout to the component registry and data fetcher, this is done in the same way as we did with the part and page.

.src/main/resources/react4xp/componentRegistry.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/componentRegistry.tsx[]
----

.src/main/resources/react4xp/dataFetcher.ts
[code,TypeScript]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/dataFetcher.ts[]
----

And finally we need to update the xml file to match the descriptor, this is done in the same way as the page.

.src/main/resources/site/layouts/TwoColumn/TwoColumn.xml
[code,xml]
----
include::{snippet}appendix/upgrade/layouts/layoutv6/TwoColumns.xml[]
----

Now we have a fully functional layout component that is using the new regions and component registry.

(Migrate thymeleaf etc, minimal example) 0

And just like that we have not only upgraded the old component, but also made it compatible with the new ones!